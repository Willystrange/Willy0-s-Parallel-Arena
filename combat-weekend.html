<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <title>Combat</title>
  <script src="quest.js"></script>
  <style>
    
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: url('background.jpg') no-repeat center center fixed;
      background-size: cover;
      color: #333;
      transition: background-color 0.3s, color 0.3s;
      position: relative;
      overflow: hidden;
    }

    .content {
      overflow-y: auto;
      height: 100vh;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    .content::-webkit-scrollbar {
      display: none;
    }

    .top-bar {
      height: 100px;
      background-color: #d1d1d6;
      display: flex;
      align-items: center;
      padding: 10px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      justify-content: space-between;
    }

    .header-info {
      display: flex;
      flex-direction: column;
      margin: 0 20px;
    }

    .header-info h3,
    .header-info p {
      margin: 0;
      padding: 0;
    }

    #player-money {
      display: none;
    }

    .combat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px 0;
      box-sizing: border-box;
    }

    #combat-log {
      width: 100%;
      padding: 10px;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      height: 300px;
      overflow-y: auto;
    }

    .combat-actions-wrapper {
      position: fixed;
      bottom: 0;
      width: 100%;
      background-color: #fff;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
      padding-top: 10px;
    }

    body.web-app .combat-actions-wrapper {
      bottom: 50px;
    }

    @media (min-width: 1024px) {
      .combat-actions-wrapper {
        position: absolute;
      }
    }

    .combat-actions {
      display: flex;
      justify-content: space-around;
    }

    .combat-actions button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      padding: 0;
      font-size: 0;
      line-height: 0;
      background-color: transparent;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.3s;
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
    }

    .combat-actions button#defense-button {
      background-image: url('defense.png');
    }

    .combat-actions button#attack-button {
      background-image: url('attaque.png');
    }

    .combat-actions button#special-button {
      background-image: url('special.png');
    }

    .combat-actions button#items-button {
      background-image: url('inventaire.png');
    }

    .combat-actions button#special-button.bright {
      filter: brightness(1.5) drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));
    }

    .combat-actions button#special-button.grow {
      transform: scale(1.1);
    }

    #item-selection {
      display: none;
      text-align: center;
      margin-top: 10px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      max-height: 300px;
      overflow-y: auto;
      color: white;
    }

    #item-selection button {
      display: block;
      width: 100%;
      max-width: 200px;
      padding: 15px;
      margin: 10px auto;
      font-size: 18px;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background-color: #4CAF50;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      transition: background-color 0.3s, transform 0.3s;
    }

    #item-selection button:hover {
      background-color: #45a049;
      transform: scale(1.05);
    }

    #item-selection button:active {
      background-color: #388e3c;
      transform: scale(1.02);
    }

    /* Mode sombre */
    @media (prefers-color-scheme: dark) {
      body, .top-bar, .combat-actions-wrapper, #combat-log, #item-selection {
        background-color: #333;
        color: #e0e0e0;
      }

      #combat-log, #item-selection {
        border-color: #444;
      }

      .combat-actions button, #item-selection button {
        background-color: #444;
        color: #e0e0e0;
        border-color: #555;
      }

      .combat-actions button:hover, #item-selection button:hover {
        background-color: #555;
      }
    }

    .special-bar {
      width: 100%;
      background-color: #ddd;
      border-radius: 5px;
      height: 5px;
      overflow: hidden;
      margin: 5px 0;
    }

    .special-fill {
      height: 100%;
      width: 0;
      background-color: #4CAF50;
      transition: width 0.3s ease-in-out;
    }

    .event-wheel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid #4CAF50;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      z-index: 2000;
      text-align: center;
    }

    .event-name {
      font-size: 24px;
      font-weight: bold;
      color: #4CAF50;
    }

  </style>
</head>

<body>
  <div class="content">
    <div class="top-bar">
      <div class="header-info">
        <h3 id="player-name"></h3>
        <p id="player-pv"></p>
        <div id="player-special-bar" class="special-bar">
          <div id="player-special-fill" class="special-fill"></div>
        </div>
        <p id="player-attack"></p>
        <p id="player-defense"></p>
      </div>
      <div class="header-info">
        <h3 id="opponent-name"></h3>
        <p id="opponent-pv"></p>
        <div id="opponent-special-bar" class="special-bar">
          <div id="opponent-special-fill" class="special-fill"></div>
        </div>
        <p id="opponent-attack"></p>
        <p id="opponent-defense"></p>
      </div>
    </div>

    <div class="combat-container">
      <div id="combat-log"></div>
    </div>

    <div class="combat-actions-wrapper">
      <div class="combat-actions">
        <button id="attack-button" onclick="handleAttack(playerCharacter, opponentCharacter, true);"></button>
        <button id="defense-button" onclick="handleDefense(playerCharacter, opponentCharacter, true);"></button>
        <button id="special-button" onclick="useSpecialAbility(playerCharacter, opponentCharacter, true);"></button>
        <button id="items-button" onclick="showItemSelection()"></button>
      </div>
      <div id="item-selection">
        <button onclick="hideItemSelection()">Annuler</button>
      </div>
    </div>
  </div>
  <div id="event-wheel" class="event-wheel" style="display: none;">
    <div class="event-name" id="event-name"></div>
  </div>
  </div>
  <script type="module">
    // Importation des modules Firebase
    import {initializeApp} from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
    import {getPerformance} from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-performance.js';

    // Configuration Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyAwIIKfoYwdtFD63yKhVggZOAnooQion-M",
      authDomain: "willy0s-parallel-arena.firebaseapp.com",
      databaseURL: "https://willy0s-parallel-arena-default-rtdb.firebaseio.com",
      projectId: "willy0s-parallel-arena",
      storageBucket: "willy0s-parallel-arena.appspot.com",
      messagingSenderId: "683284732830",
      appId: "1:683284732830:web:ef7fb4cf1c88f73eead48f",
      measurementId: "G-85B8R4NKNM"
    };

    // Initialisation de Firebase
    const app = initializeApp(firebaseConfig);

    // Initialisation de Firebase Performance Monitoring
    const perf = getPerformance(app);
    if ('PerformanceObserver' in window) {
      // Créer un observateur pour les entrées de type "paint" (pour FCP)
      const paintObserver = new PerformanceObserver((list) => {
        const entries = list.getEntriesByName('first-contentful-paint');
        if (entries.length > 0) {
          const fcp = entries[0].startTime;
          console.log('First Contentful Paint (FCP):', fcp, 'ms');
        }
      });

      // Observer les événements de type "paint"
      paintObserver.observe({type: 'paint', buffered: true});

      // Créer un observateur pour les entrées de type "first-input" (pour FID)
      const fidObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach((entry) => {
          if (entry.entryType === 'first-input') {
            const fid = entry.processingStart - entry.startTime;
            console.log('First Input Delay (FID):', fid, 'ms');
          }
        });
      });

      // Observer les événements de type "first-input"
      fidObserver.observe({type: 'first-input', buffered: true});
    }
  </script>
  <script>
    let playerCharacter = null;
    let opponentCharacter = null;
    let specialAbility = 0;
    
    if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true) {
      document.body.classList.add('web-app');
    } else {
      document.body.classList.add('normal-app');
    }

    

    const events = [
      "PV égaux",
      "Chargement /2",
      "Sans défense",
      "Sans objet",
      "Points X2",
      "XP X2"
    ];

    function spinEventWheel() {
      const eventWheel = document.getElementById("event-wheel");
      const eventNameElement = document.getElementById("event-name");
      let spinCount = 0;
      const totalSpins = 17; // Nombre de tours avant de s'arrêter
      const spinDuration = 150; // Durée de chaque affichage (ms)

      eventWheel.style.display = "block";

      const spinInterval = setInterval(() => {
        const randomIndex = Math.floor(Math.random() * events.length);
        eventNameElement.innerText = events[randomIndex];
        spinCount++;

        if (spinCount > totalSpins) {
          clearInterval(spinInterval);
          const selectedEventIndex = Math.floor(Math.random() * events.length);
          const selectedEvent = events[selectedEventIndex];
          eventNameElement.innerText = selectedEvent;


          // Enregistrement de l'événement sélectionné
          localStorage.setItem("currentEvent", selectedEvent);

          setTimeout(() => {
            eventWheel.style.display = "none"; // Cache la roue après l'affichage
            applicationEvent();
          }, 2000); // Affiche l'événement sélectionné pendant 2 secondes
        }
      }, spinDuration);
    }

    function getUserData() {
      let userData = localStorage.getItem('userData');
      if (userData) {
        userData = JSON.parse(userData);
        return userData;
      }
      return {}; // Retourner un objet vide si userData est null ou undefined
    }

    const userData = getUserData();
    console.log(userData.difficulty);

    function saveUserData(userData) {
      localStorage.setItem('userData', JSON.stringify(userData));
    }

    // Chargement de la sauvegarde de partie depuis localStorage
    let sauvegarde = null;
    try {
      sauvegarde = JSON.parse(localStorage.getItem("savepartie_weekend"));
    } catch (e) {
      console.error('Erreur lors du parsing de la sauvegarde :', e);
    }
    if (sauvegarde) {
      console.log('Sauvegarde trouvée :', sauvegarde);
    }

    // Fonction qui charge les personnages depuis la sauvegarde
    function chargerPartie() {
      const sauvegardeLocal = JSON.parse(localStorage.getItem("savepartie_weekend"));
      if (!sauvegardeLocal) {
        console.warn("Aucune sauvegarde trouvée.");
        return;
      }
      // Affectation directe des objets sauvegardés aux variables globales
      playerCharacter = sauvegardeLocal.playerCharacter;
      opponentCharacter = sauvegardeLocal.opponentCharacter;

      if (playerCharacter.chargement2) {
        const selectedEvent = "Chargement /2";
        localStorage.setItem("currentEvent", selectedEvent);
        applicationEvent();
      } else if (playerCharacter.nodefense) {
        const selectedEvent = "Sans défense";
        localStorage.setItem("currentEvent", selectedEvent);
        applicationEvent();
      } else if (playerCharacter.noobject) {
        const selectedEvent = "Sans objet";
        localStorage.setItem("currentEvent", selectedEvent);
        applicationEvent();
      }

      console.log("Partie chargée avec succès !");
      updateUI(); // Mise à jour de l'interface après chargement
    }

    // Si une partie a déjà commencé et qu'une sauvegarde existe, on la charge
    if (userData.partie_commencee && sauvegarde) {
      chargerPartie();
    } else {
      spinEventWheel();
      // Sinon, on initialise les personnages à partir des données stockées en sessionStorage

      // Récupération et initialisation du personnage du joueur
      const storedPlayer = sessionStorage.getItem('playerCharacter');
      if (storedPlayer) {
        playerCharacter = JSON.parse(storedPlayer);

        // Initialisation des nouvelles propriétés
        playerCharacter.perte_att = 0;
        playerCharacter.Oiseaudefense = 0;
        playerCharacter.perte_defense_colorina = 0;
        playerCharacter.pv_maximum = playerCharacter.pv;
        playerCharacter.amulette_soin = 0;
        playerCharacter.attaque_epee = 0;
        playerCharacter.attaque_elixir = 0;
        playerCharacter.armure = 0;
        playerCharacter.degats_partie = 0;
        playerCharacter.objets_partie = 0;
        playerCharacter.capacite_partie = 0;
        playerCharacter.degats_partie_base = 0;
        playerCharacter.objets_soin = 0;
        playerCharacter.defense_bouton = 0;
        playerCharacter.defense_droit = 0;
        playerCharacter.defense_solide = 0;
        playerCharacter.defense_partie = 0;
        playerCharacter.immobilisation = 0;
        playerCharacter.sboonie_attaque = 0;
        playerCharacter.poulpy_att = 0;
        playerCharacter.objets_utilise = 0;
        playerCharacter.inventaire_objets = false;
        playerCharacter.amuletteUses = 0;
        playerCharacter.armureUses = 0;
        playerCharacter.tour = 1;
        playerCharacter.cape = false;
        playerCharacter.capeUses = 0;
        playerCharacter.crystalUses = 0;
        playerCharacter.inconnu_super = 0;
        playerCharacter.last_action = 0;
        
        playerCharacter.chargement2 = false;
        playerCharacter.nodefense = false;
        playerCharacter.points2 = false;
        playerCharacter.xp2 = false;
        playerCharacter.noobject = false;
      } else {
        // Rediriger vers index.html si les données du joueur ne sont pas trouvées
        window.location.href = 'index.html';
      }

      // Récupération et initialisation du personnage adverse
      const storedOpponent = sessionStorage.getItem('opponentCharacter');
      if (storedOpponent) {
        opponentCharacter = JSON.parse(storedOpponent);

        opponentCharacter.perte_att = 0;
        opponentCharacter.Oiseaudefense = 0;
        opponentCharacter.perte_defense_colorina = 0;
        opponentCharacter.pv_maximum = opponentCharacter.pv;
        opponentCharacter.immobilisation = 0;
        opponentCharacter.defense_bouton = 0;
        opponentCharacter.defense_droit = 0;
        opponentCharacter.sboonie_attaque = 0;
        opponentCharacter.poulpy_att = 0;
        opponentCharacter.degats_subit = 0;
        opponentCharacter.inconnu_super = 0;
        opponentCharacter.next_choice = "0";
        opponentCharacter.chargement2 = false;
        opponentCharacter.nodefense = false;
      } else {
        // Rediriger vers index.html si les données de l'adversaire ne sont pas trouvées
        window.location.href = 'index.html';
      }
    }

    console.log('Player Character :', playerCharacter);
    console.log('Opponent Character :', opponentCharacter);


    // Empêcher le retour en arrière vers la page précédente
    history.replaceState(null, null, window.location.href);

    // Initialiser spe (capacité spéciale)
    let spe = playerCharacter.spe;

    // Mettre à jour l'interface utilisateur avec les statistiques du joueur
    document.getElementById('player-name').textContent = `${playerCharacter.name}`;
    document.getElementById('player-pv').textContent = `PV: ${playerCharacter.pv}`;

    // Mettre à jour l'interface utilisateur avec les statistiques de l'adversaire
    document.getElementById('opponent-name').textContent = `${opponentCharacter.name}`;
    document.getElementById('opponent-pv').textContent = `PV: ${opponentCharacter.pv}`;

    // Récupérer la capacité spéciale du joueur depuis sessionStorage
    specialAbility = spe;
    // Mettre à jour le bouton de capacité spéciale
    updateSpecialButton();
    function updateSpecialBar(character, elementId) {
      const specialBar = document.getElementById(elementId);
      const fillElement = specialBar.querySelector('.special-fill');
      const maxSpecialAbility = 1; // La valeur maximale pour la capacité spéciale
      const widthPercentage = (character.spe / maxSpecialAbility) * 100;
      fillElement.style.width = `${widthPercentage}%`;
    }

    function updateUI() {
      playerCharacter.pv = Math.round(playerCharacter.pv);
      opponentCharacter.pv = Math.round(opponentCharacter.pv);
      document.getElementById('player-name').textContent = `${playerCharacter.name}`;
      document.getElementById('player-pv').textContent = `PV: ${playerCharacter.pv}`;
      updateSpecialBar(playerCharacter, 'player-special-bar');

      document.getElementById('opponent-name').textContent = `${opponentCharacter.name}`;
      document.getElementById('opponent-pv').textContent = `PV: ${opponentCharacter.pv}`;
      updateSpecialBar(opponentCharacter, 'opponent-special-bar');
    }
    updateUI();



    function applicationEvent() {
      let event = localStorage.getItem("currentEvent");
      if (event === "PV égaux") {
        alert("PV égaux");
        if (playerCharacter.pv > opponentCharacter.pv) {
          opponentCharacter.pv = playerCharacter.pv;
        } else if (playerCharacter.pv < opponentCharacter.pv) {
          playerCharacter.pv = opponentCharacter.pv;
        }
        updateUI();
      } else if (event === "Chargement /2") {
        alert("Chargement /2");
        playerCharacter.chargement2 = true;
        opponentCharacter.chargement2 = true;
        playerCharacter.partie_mode = 1;
      } else if (event === "Sans défense") {
        alert("Sans défense");
        playerCharacter.nodefense = true;
        opponentCharacter.nodefense = true;
        playerCharacter.partie_mode = 2;
        document.getElementById('defense-button').style.display = 'none';
      } else if (event === "Sans objets") {
        alert("Sans objet");
        document.getElementById('items-button').style.display = 'none';
        playerCharacter.noobject = true;
        playerCharacter.partie_mode = 3;
      } else if (event === "Points X2") {
        alert("Points X2");
        playerCharacter.points2 = true;
        playerCharacter.partie_mode = 4;
      } else if (event === "XP X2") {
        alert("XP X2");
        playerCharacter.xp2 = true;
        playerCharacter.partie_mode = 5;
      }

    }


    // Mettre à jour l'interface utilisateur initialement
    function updateSpecialButton() {
      const specialButton = document.getElementById('special-button');
      const maxSpecialAbility = 1; // La valeur maximale pour la capacité spéciale

      // Ajouter ou retirer la classe de brillance et d'agrandissement selon la capacité spéciale
      if (specialAbility >= maxSpecialAbility) {
        specialButton.classList.add('bright');
        specialButton.classList.add('grow'); // Ajout de la classe pour agrandir le bouton
        specialButton.textContent = 'Capacité spéciale'; // Affichage du texte si nécessaire
      } else {
        specialButton.classList.remove('bright');
        specialButton.classList.remove('grow'); // Retrait de la classe pour revenir à la taille normale
        specialButton.textContent = `${specialAbility.toFixed(1)} / 1`; // Affichage du texte si nécessaire
      }
    }

    function adversairepasser_tour() {
      updateSpecialBar(opponentCharacter, 'opponent-special-bar');
      updateUI();
      if (opponentCharacter.inconnu_super >= 1) {
        opponentCharacter.inconnu_super -= 1;
      }
      if (opponentCharacter.immobilisation >= 1) {
        opponentCharacter.immobilisation -= 1;
      }
      if (opponentCharacter.defense_droit > 0) {
        opponentCharacter.defense_droit -= 1;
      }
      if (opponentCharacter.perte_att > 0) {
        opponentCharacter.perte_att -= 1;
        if (opponentCharacter.perte_att == 0) {
          opponentCharacter.attaque = Math.round(opponentCharacter.attaque / 0.75);
        }
      }
      if (opponentCharacter.poulpy_att > 0) {
        opponentCharacter.poulpy_att -= 1;
        if (opponentCharacter.poulpy_att == 0) {
          opponentCharacter.defense = Math.round(opponentCharacter.defense / 0.85);
        }
      }
      if (opponentCharacter.Oiseaudefense > 0) {
        opponentCharacter.Oiseaudefense -= 1;
        if (opponentCharacter.Oiseaudefense == 0) {
          opponentCharacter.defense -= 20;
        }
      }
      if (opponentCharacter.perte_defense_colorina > 0) {
        opponentCharacter.perte_defense_colorina -= 1;
        if (opponentCharacter.perte_defense_colorina == 0) {
          opponentCharacter.defense = Math.round(opponentCharacter.defense / 0.85);
        }
      }
      if (opponentCharacter.sboonie_attaque > 0) {
        opponentCharacter.sboonie_attaque -= 1;
        if (opponentCharacter.sboonie_attaque == 0) {
          opponentCharacter.attaque = Math.round(opponentCharacter.attaque / 0.85);
        }
      }
    }


    function joueurpasser_tour() {
      updateSpecialBar(playerCharacter, 'player-special-bar');
      updateUI();
      playerCharacter.tour += 1;
      playerCharacter.inventaire_objets = false;
      playerCharacter.objets_utilise = 0;
      if (playerCharacter.inconnu_super >= 1) {
        playerCharacter.inconnu_super -= 1;
      }
      if (playerCharacter.cape) {
        playerCharacter.cape = false;
      }
      if (playerCharacter.immobilisation >= 1) {
        playerCharacter.immobilisation -= 1;
      }
      if (playerCharacter.amulette_soin > 0) {
        playerCharacter.pv = Math.round(playerCharacter.pv + (playerCharacter.pv_maximum * 0.02));
      }
      if (playerCharacter.defense_droit > 0) {
        playerCharacter.defense_droit -= 1;
      }
      if (playerCharacter.perte_att > 0) {
        playerCharacter.perte_att -= 1;
        if (playerCharacter.perte_att == 0) {
          playerCharacter.attaque = Math.round(playerCharacter.attaque / 0.75);
        }
      }
      if (playerCharacter.poulpy_att > 0) {
        playerCharacter.poulpy_att -= 1;
        if (playerCharacter.poulpy_att == 0) {
          playerCharacter.defense = Math.round(playerCharacter.defense / 0.85);
        }
      }
      if (playerCharacter.Oiseaudefense > 0) {
        playerCharacter.Oiseaudefense -= 1;
        if (playerCharacter.Oiseaudefense == 0) {
          playerCharacter.defense -= 20;
        }
      }
      if (playerCharacter.perte_defense_colorina > 0) {
        playerCharacter.perte_defense_colorina -= 1;
        if (playerCharacter.perte_defense_colorina == 0) {
          playerCharacter.defense = Math.round(playerCharacter.defense / 0.85);
        }
      }
      if (playerCharacter.sboonie_attaque > 0) {
        playerCharacter.sboonie_attaque -= 1;
        if (playerCharacter.sboonie_attaque == 0) {
          playerCharacter.attaque = Math.round(playerCharacter.attaque / 0.85);
        }
      }
      sauvegarderPartie(playerCharacter, opponentCharacter)

    }

    function showItemSelection() {
      const itemSelectionDiv = document.getElementById('item-selection');
      itemSelectionDiv.style.display = 'block';

      // Clear previous items
      itemSelectionDiv.innerHTML = '<h3>Choisissez un objet à utiliser</h3>';

      const userData = getUserData();
      const availableItems = [];

      // Vérifier si l'amulette de régénération a déjà été utilisée
      if (userData.crystal_acheté > 0 && playerCharacter.crystalUses < 2) {
        availableItems.push({
          name: 'Crystal de renouveau', count: userData.crystal_acheté
        });
      }
      if (userData.bouclier_solide_acheté > 0) {
        availableItems.push({name: 'Bouclier solide', count: userData.bouclier_solide_acheté});
      }
      if (userData.Cape_acheté > 0 && playerCharacter.capeUses < 2) {
        availableItems.push({name: "Cape de l'ombre", count: userData.Cape_acheté});
      }
      if (userData.Potion_de_Santé_acheté > 0) {
        availableItems.push({name: 'Potion de Santé', count: userData.Potion_de_Santé_acheté});
      }
      if (userData.armure_fer_acheté > 0 && playerCharacter.armureUses < 2) {
        // L'armure ne s'affiche plus si elle a été utilisée deux fois
        availableItems.push({name: 'Armure de Fer', count: userData.armure_fer_acheté});
      }
      if (userData.Amulette_de_Régénération_acheté > 0 && playerCharacter.amuletteUses < 1) {
        // L'amulette ne s'affiche plus si elle a été utilisée une fois
        availableItems.push({name: 'Amulette de Régénération', count: userData.Amulette_de_Régénération_acheté});
      }
      if (userData.epee_tranchante_acheté > 0) {
        availableItems.push({name: 'Épée Tranchante', count: userData.epee_tranchante_acheté});
      }
      if (userData.elixir_puissance_acheté > 0) {
        availableItems.push({name: 'Elixir de Puissance', count: userData.elixir_puissance_acheté});
      }


      // Si aucun objet n'a été utilisé
      if (playerCharacter.objets_utilise === 0) {
        // Si inventaire_objets est à false, on sélectionne 3 objets aléatoirement
        if (!playerCharacter.inventaire_objets) {
          playerCharacter.selectedItems = [];

          // Mélanger les items disponibles et en sélectionner 3
          const shuffledItems = availableItems.sort(() => 0.5 - Math.random());
          playerCharacter.selectedItems = shuffledItems.slice(0, 3);

          // Passer inventaire_objets à true pour se souvenir de la sélection
          playerCharacter.inventaire_objets = true;
        }

        // Afficher les 3 objets sélectionnés
        playerCharacter.selectedItems.forEach(item => {
          const itemButton = document.createElement('button');
          itemButton.textContent = `${item.name} (${item.count})`;
          itemButton.onclick = function () {useItem(item.name);};
          itemSelectionDiv.appendChild(itemButton);
        });

        // Ajouter le bouton Annuler
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Annuler';
        cancelButton.onclick = hideItemSelection;
        itemSelectionDiv.appendChild(cancelButton);

      } else if (playerCharacter.objets_utilise !== 0) {
        // Si des objets ont déjà été utilisés, proposer uniquement le bouton Annuler
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Annuler';
        cancelButton.onclick = hideItemSelection;
        itemSelectionDiv.appendChild(cancelButton);
      }
    }

    function hideItemSelection() {
      document.getElementById('item-selection').style.display = 'none';
    }

    function useItem(itemName) {
      const userData = getUserData();
      playerCharacter.objets_utilise = 1;
      switch (itemName) {
        case 'Crystal de renouveau':
          userData.crystal_acheté -= 1;
          playerCharacter.crystalUses += 1;
          playerCharacter.spe += 0.8;
          if (playerCharacter.spe > 1) {
            playerCharacter.spe = 1;
          }
          saveUserData(userData);
          updateUI();
          break;
        case "Cape de l'ombre":
          userData.Cape_acheté -= 1;
          playerCharacter.capeUses += 1;
          playerCharacter.cape = true;
          saveUserData(userData);
          break;
        case 'Potion de Santé':
          userData.Potion_de_Santé_acheté -= 1;
          playerCharacter.pv += 1100;

          if (playerCharacter.pv > playerCharacter.pv_maximum) {
            playerCharacter.pv = playerCharacter.pv_maximum;
          }
          playerCharacter.objets_partie += 1;
          playerCharacter.objets_soin += 1;
          saveUserData(userData);
          break;

        case 'Amulette de Régénération':
          userData.Amulette_de_Régénération_acheté -= 1;
          // Amulette soin devient un effet permanent de régénération
          playerCharacter.amuletteUses += 1;
          playerCharacter.amulette_soin = 1; // On garde une régénération constante
          playerCharacter.objets_partie += 1;
          playerCharacter.objets_soin += 1;
          saveUserData(userData);
          break;

        case 'Épée Tranchante':
          userData.epee_tranchante_acheté -= 1;
          // Appliquer une augmentation permanente de l'attaque
          playerCharacter.attaque = Math.round(playerCharacter.attaque * 1.05); // Moins fort mais permanent
          playerCharacter.objets_partie += 1;
          saveUserData(userData);
          break;

        case 'Elixir de Puissance':
          userData.elixir_puissance_acheté -= 1;
          // L'effet reste permanent avec une augmentation modérée
          playerCharacter.attaque += 50; // Réduction de l'effet initial mais permanent
          playerCharacter.objets_partie += 1;
          saveUserData(userData);
          break;

        case 'Armure de Fer':
          userData.armure_fer_acheté -= 1;
          // Réduire l'attaque de l'adversaire de façon permanente
          playerCharacter.armureUses += 1;
          opponentCharacter.attaque = Math.round(opponentCharacter.attaque * 0.90); // Moins d'effet mais permanent
          playerCharacter.objets_partie += 1;
          saveUserData(userData);
          break;

        case 'Bouclier solide':
          userData.bouclier_solide_acheté -= 1;
          // Appliquer une augmentation permanente de la défense
          playerCharacter.defense += 15; // Réduit l'effet initial mais permanent
          playerCharacter.objets_partie += 1;
          saveUserData(userData);
          break;

        default:
          console.log('Objet non reconnu');
      }

      // Mettre à jour l'interface utilisateur

      document.getElementById('player-pv').textContent = `PV: ${playerCharacter.pv}`;

      // Masquer la sélection des objets
      hideItemSelection();

      // Ajoute une entrée dans le journal de combat
      const combatLog = document.getElementById('combat-log');
      const itemLogEntry = document.createElement('p');
      itemLogEntry.textContent = `${itemName} utilisé !`;
      combatLog.appendChild(itemLogEntry);

      scrollToBottom(); // Assurez-vous que la vue défile vers le bas
    }

    // Fonction utilitaire pour ajouter un message dans le journal de combat
    function addCombatLog(message, color = "#9966CC") {
      const combatLog = document.getElementById("combat-log");
      const logEntry = document.createElement("p");
      logEntry.textContent = message;
      logEntry.style.color = color;
      combatLog.appendChild(logEntry);
    }

    // Fonction utilitaire pour mettre à jour l’affichage (PV, barres, UI, scroll)
    function updateDisplay(isPlayer, character) {
      document.getElementById(isPlayer ? "player-pv" : "opponent-pv").textContent = `PV: ${character.pv}`;
      if (isPlayer) updateSpecialButton();
      updateSpecialBar(playerCharacter, "player-special-bar");
      updateSpecialBar(opponentCharacter, "opponent-special-bar");
      updateUI();
      scrollToBottom();
    }

    //
    // 1. useSpecialAbility
    //
    function useSpecialAbility(character, opponent, isPlayer) {
      if (character.spe < 1) return;

      // Décrément de la ressource spéciale
      character.spe -= 1;
      if (isPlayer) {
        specialAbility -= 1;
        character.capacite_partie += 1;
        character.last_action = 2;
      }

      let specialLogMessage = "";

      // Cas d'annulation de l'action
      if (character.immobilisation >= 1) {
        specialLogMessage = `${character.name} utilise sa capacité spéciale ! Mais ${opponent.name} l'a immobilisé, donc l'attaque échoue et rien ne se passe.`;
        addCombatLog(specialLogMessage);
        // On ne fait rien de plus (opponent.pv reste inchangé)
      } else if (opponent.defense_bouton === 1) {
        opponent.defense_bouton = 0;
        specialLogMessage = `${character.name} utilise sa capacité spéciale ! Mais ${opponent.name} l'en empêche, donc l'attaque échoue et rien ne se passe.`;
        addCombatLog(specialLogMessage);
      } else if (character.inconnu_super >= 1) {
        specialLogMessage = `${character.name} ne peut pas utiliser sa capacité spéciale, car ${character.name} la bloqué pour encore ${character.inconnu_super} tours.`;
        // Remboursement du spe consommé
        character.spe += 1;
        addCombatLog(specialLogMessage);
        handleAttack(character, opponent, isPlayer);
        updateDisplay(isPlayer, character);
        return;
      } else {
        // Action spécifique en fonction du personnage
        switch (character.name) {
          case "Diva": {
            opponent.attaque *= 0.75;
            character.spe -= 0.25;
            specialLogMessage = `${character.name} utilise sa capacité spéciale ! L'attaque de ${opponent.name} est réduite à ${Math.round(opponent.attaque.toFixed(2))} pour les 3 prochains tours.`;
            opponent.perte_att += (isPlayer ? 3 : 4);
            addCombatLog(specialLogMessage);
            handleAttack(character, opponent, isPlayer);
            break;
          }
          case "Willy": {
            character.spe -= 0.25;
            specialAbility -= 0.25;
            const opponentDefenseModifiee = 0.9 + Math.random() * 0.2; // Entre 0.9 et 1.1
            const opponentDefensee = Math.round(opponent.defense * opponentDefenseModifiee);
            opponent.pv += 2 * (opponentDefensee - character.attaque);
            specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il effectue 3 attaques !\n\n${character.name} attaque ${opponent.name} et inflige ${Math.round(2 * (character.attaque - opponentDefensee))} points de dégâts.`;
            character.degats_partie += 2 * (character.attaque - opponentDefensee);
            addCombatLog(specialLogMessage);
            handleAttack(character, opponent, isPlayer);
            break;
          }
          case "Baleine": {
            if (character.defense < 29) {
              specialLogMessage = "Baleine n'a plus assez de défense pour utiliser sa capacité spéciale, il va donc attaquer.";
              addCombatLog(specialLogMessage);
              handleAttack(character, opponent, isPlayer);
            } else {
              specialLogMessage = "Baleine utilise sa capacité spéciale ! Il perd 15 de défense et gagne 1000 PV !";
              character.spe -= 0.25;
              if (isPlayer) specialAbility -= 0.25;
              character.defense -= 15;
              character.pv += 1000;
              addCombatLog(specialLogMessage);
              handleAttack(character, opponent, isPlayer);
            }
            break;
          }
          case "Doudou": {
            character.spe -= 0.25;
            let regeneratedAmount = character.pv < (character.pv_max / 2)
              ? Math.ceil(character.pv * 0.15)
              : Math.ceil(character.pv * 0.05);
            specialLogMessage = `${character.name} régénère ${Math.round(regeneratedAmount)} PV.`;
            character.pv = Math.min(character.pv + regeneratedAmount, character.pv_max);
            addCombatLog(specialLogMessage);
            handleAttack(character, opponent, isPlayer);
            break;
          }
          case "Cocobi": {
            const reductionAmount = Math.ceil(opponent.pv_maximum * 0.12);
            opponent.pv = Math.max(opponent.pv - reductionAmount, 0);
            specialLogMessage = `${character.name} utilise sa capacité spéciale ! ${opponent.name} perd ${Math.round(reductionAmount)} PV.`;
            character.degats_partie += reductionAmount;
            addCombatLog(specialLogMessage);
            break;
          }
          case "Coeur": {
            const specialDamage = Math.round(character.attaque * 1.5);
            const absorbedHealth = Math.round(specialDamage * (character.pv > (character.pv_max / 2) ? 0.1 : 0.15));
            opponent.pv = Math.max(opponent.pv - specialDamage, 0);
            character.pv = Math.min(character.pv + absorbedHealth, character.pv_max);
            specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(specialDamage)} points de dégâts et récupère ${Math.round(absorbedHealth)} PV.`;
            character.degats_partie += specialDamage;
            addCombatLog(specialLogMessage);
            break;
          }
          case "Grours": {
            const Damage = 500 + character.attaque;
            const defenseValue = Math.round(opponent.defense * 0.5);
            const netDamage = Math.round(Damage - defenseValue);
            opponent.pv -= netDamage;
            specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${netDamage} points de dégâts à ${opponent.name}, ignorant le bouclier.`;
            character.degats_partie += netDamage;
            addCombatLog(specialLogMessage);
            break;
          }
          case "Poulpy": {
            const poulpyDamage = Math.round(character.attaque * 1.75);
            const effectiveDefense = Math.round(opponent.defense * 0.6);
            const netDamage = Math.max(0, poulpyDamage - effectiveDefense);
            opponent.pv -= netDamage;
            opponent.defense *= 0.85;
            opponent.poulpy_att += 3;
            specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(netDamage)} points de dégâts à ${opponent.name}, ignore 50% de sa défense et réduit sa défense de 15% pour les 2 prochains tours.`;
            character.degats_partie += netDamage;
            addCombatLog(specialLogMessage);
            break;
          }
          case "Oiseau": {
            const DamageOiseau = character.attaque * 2.5;
            character.defense += 20;
            specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(DamageOiseau)} points de dégâts et gagne 20 de défense.`;
            opponent.pv -= DamageOiseau;
            character.Oiseaudefense += 2;
            character.degats_partie += DamageOiseau;
            addCombatLog(specialLogMessage);
            break;
          }
          case "Colorina": {
            const colorinaDamage = Math.round(character.attaque * 0.85);
            opponent.pv -= colorinaDamage;
            opponent.defense *= 0.85;
            opponent.perte_defense_colorina += 4;
            specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(colorinaDamage)} points de dégâts et réduit la défense de ${opponent.name} de 15% pour les 3 prochains tours.`;
            character.degats_partie += colorinaDamage;
            addCombatLog(specialLogMessage);
            break;
          }
          case "Rosalie": {
            const rosalieDamage = Math.round(character.attaque * 2);
            if (Math.random() < 0.25) {
              opponent.immobilisation = 1;
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Elle inflige ${rosalieDamage} points de dégâts et immobilise ${opponent.name} pour un tour.`;
            } else {
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Elle inflige ${rosalieDamage} points de dégâts.`;
            }
            opponent.pv = Math.max(opponent.pv - rosalieDamage, 0);
            character.degats_partie += rosalieDamage;
            addCombatLog(specialLogMessage);
            break;
          }
          case "Sboonie": {
            const pvsupp = Math.round(character.pv_max * 0.08);
            character.pv += pvsupp;
            opponent.pv -= 50;
            opponent.attaque = Math.round(opponent.attaque * 0.85);
            opponent.sboonie_attaque += (isPlayer ? 1 : 2);
            specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il régénère ${Math.round(pvsupp)} PV, inflige 50 de dégâts et réduit de 15% l'attaque de ${opponent.name} pour le prochain tour.`;
            addCombatLog(specialLogMessage);
            break;
          }
          case "Inconnu": {
            opponent.inconnu_super += (isPlayer ? 4 : 3);
            character.attaque += 25;
            character.defense += 25;
            specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il augmente son attaque et sa défense de 15 et empêche ${opponent.name} d'utiliser sa capacité spéciale pendant 3 tours.`;
            addCombatLog(specialLogMessage);
            handleAttack(character, opponent, isPlayer);
            break;
          }
          default: {
            specialLogMessage = `${character.name} utilise sa capacité spéciale ! Effet spécifique à définir.`;
            addCombatLog(specialLogMessage);
          }
        }
      }

      updateDisplay(isPlayer, character);
      // Si le personnage joueur ne fait pas partie de certains cas spéciaux,
      // on lance le tour de l'adversaire
      if (isPlayer && !["Diva", "Willy", "Baleine", "Doudou"].includes(character.name)) {
        opponentTurn();
      }
    }

    //
    // 2. opponentTurn
    //
    // ---------------------------------------
    // Fonctions utilitaires
    // ---------------------------------------

    // Calcule la distance de Manhattan entre deux tableaux numériques
    function manhattanDistance(arr1, arr2) {
      let distance = 0;
      for (let i = 0; i < arr1.length; i++) {
        distance += Math.abs(arr1[i] - arr2[i]);
      }
      return distance;
    }

    // Sélection aléatoire pondérée parmi un tableau d'actions avec leurs occurrences
    function weightedRandomAction(actionCounts) {
      const total = Object.values(actionCounts).reduce((sum, count) => sum + count, 0);
      let rand = Math.random() * total;
      for (let action in actionCounts) {
        rand -= actionCounts[action];
        if (rand <= 0) {
          return action;
        }
      }
      return null;
    }

    // ---------------------------------------
    // Système d'historique et prédiction
    // ---------------------------------------

    // Recherche des états similaires dans l'historique en utilisant la distance de Manhattan
    function findSimilarData(currentState, data) {
      console.log("Recherche de données similaires...");
      // Reconstruction de l'état en excluant l'action du joueur (index 3)
      const stateToMatch = [...currentState.slice(0, 3), ...currentState.slice(4)];

      // Seuil de similarité (à ajuster selon la granularité souhaitée)
      const SIMILARITY_THRESHOLD = 2;
      const similarData = data.filter((row) => {
        const rowState = [...row.slice(0, 3), ...row.slice(4)];
        const distance = manhattanDistance(stateToMatch, rowState);
        return distance <= SIMILARITY_THRESHOLD;
      });

      console.log("Données similaires trouvées :", similarData);
      return similarData;
    }

    // Détermine l'action la plus probable (pondérée) parmi les données similaires
    function mostProbableAction(data) {
      console.log("Choix de l'action la plus probable...");
      if (data.length === 0) return null; // Aucun historique trouvé

      // Extraire les actions (situées à l'index 3)
      const actions = data.map(row => row[3]);

      // Compter les occurrences de chaque action
      const actionCounts = actions.reduce((counts, action) => {
        counts[action] = (counts[action] || 0) + 1;
        return counts;
      }, {});

      console.log("Occurrences des actions :", actionCounts);
      return weightedRandomAction(actionCounts);
    }

    // Sauvegarde l'historique dans le localStorage
    function saveHistoricalData(data) {
      localStorage.setItem("historicalData_weekend", JSON.stringify(data));
    }

    // Chargement des données historiques depuis le localStorage
    function loadHistoricalData() {
      const data = localStorage.getItem("historicalData_weekend");
      return data ? JSON.parse(data) : [];
    }

    // Chargement initial de l'historique
    const savedData = localStorage.getItem("historicalData_weekend");
    const historicalData = savedData ? JSON.parse(savedData) : [];

    // ---------------------------------------
    // Logique de l'IA et gestion des tours
    // ---------------------------------------

    // Tour de l'IA avec adaptation dynamique de la difficulté
    function iaTurn(IA, playerCharacter) {
      console.log("L'IA réfléchit...");

      // Récupération de l'action prédite
      let choice = opponentCharacter.next_choice;
      if (choice === null) {
        console.log("Aucune action prédite, choix aléatoire !");
        const possibleActions = ["attacker", "utiliser capacité spéciale", "se défendre"];
        choice = possibleActions[Math.floor(Math.random() * possibleActions.length)];
      }
      console.log("Action choisie :", choice);

      // ---------------------------------------
      // Calcul des modificateurs pour ajuster la stratégie
      // ---------------------------------------

      // 1. Adaptation dynamique en fonction de la vie du joueur
      const playerHPPercentage = Math.min(Math.ceil((playerCharacter.pv / playerCharacter.pv_max) * 100 / 20) * 20, 100);
      let dynamicModifier = 0;
      if (playerHPPercentage >= 80) {
        // Le joueur est en bonne santé, l'IA est plus prudente
        dynamicModifier = -0.2;
      } else if (playerHPPercentage <= 40) {
        // Le joueur est vulnérable, l'IA peut se montrer plus agressive
        dynamicModifier = 0.2;
      }

      // 2. Réglage global selon la difficulté choisie par l'utilisateur
      // userData.difficulty doit être défini dans votre contexte (par exemple "Easy", "Medium", "Hard")
      let difficultyFactor = 0;
      if (userData.difficulty === "Easy") {
        difficultyFactor = -0.2; // IA moins forte
      } else if (userData.difficulty === "Hard") {
        difficultyFactor = 0.2;  // IA plus forte
      } else {
        difficultyFactor = 0;    // Niveau moyen
      }

      // Fusion des deux modificateurs
      const finalModifier = dynamicModifier + difficultyFactor;
      console.log("Modificateur dynamique =", dynamicModifier, "et modificateur global =", difficultyFactor, "soit final =", finalModifier);

      // Fonction utilitaire pour choisir aléatoirement une action parmi un ensemble
      function getRandomAction(actions) {
        return actions[Math.floor(Math.random() * actions.length)];
      }

      // ---------------------------------------
      // Décision de l'IA en fonction de sa capacité spéciale et du modificateur final
      // ---------------------------------------
      if (IA.spe === 1) { // Capacité spéciale disponible
        // En présence de la capacité spéciale, l'IA choisit entre attaquer et utiliser sa capacité spéciale.
        // On compare une valeur aléatoire au seuil ajusté par finalModifier.
        if (choice === "attacker" || (choice === "0" && Math.random() > 0.5 + finalModifier)) {
          console.log("L'IA attaque.");
          handleAttack(IA, playerCharacter, false);
        } else {
          console.log("L'IA utilise sa capacité spéciale.");
          useSpecialAbility(IA, playerCharacter, false);
        }
      } else { // Capacité spéciale non disponible
        // Choix entre attaquer et se défendre
        if (choice === "se défendre" || (choice === "2" && Math.random() < 0.5 - finalModifier)) {
          console.log("L'IA se défend.");
          opponentDefense();
        } else {
          console.log("L'IA attaque.");
          handleAttack(IA, playerCharacter, false);
        }
      }

      console.log("Le tour de l'IA est terminé.");
    }

    // Fonction principale du tour de l'adversaire
    function opponentTurn() {
      // État actuel du joueur
      let Jdefense = playerCharacter.defense_droit;
      if (playerCharacter.defense_droit > 0 && playerCharacter.defense_droit < 1) {
        Jdefense = 0;
      } else if (playerCharacter.defense_droit >= 1) {
        Jdefense = 1;
      }
      let Jcs = playerCharacter.spe;
      if (playerCharacter.spe > 0 && playerCharacter.spe < 1) {
        Jcs = 0;
      } else if (playerCharacter.spe >= 1) {
        Jcs = 1;
      }
      let Jpv = Math.min(Math.ceil((playerCharacter.pv / playerCharacter.pv_max) * 100 / 20) * 20, 100);
      let Jaction = playerCharacter.last_action;
      console.log("Action du joueur :", Jaction);

      // Nouvelle donnée : mode de partie (valeur entre 1 et 5)
      let partieMode = playerCharacter.partie_mode;

      // État actuel de l'IA
      let IAdefense = opponentCharacter.defense_droit;
      if (opponentCharacter.defense_droit > 0 && opponentCharacter.defense_droit < 1) {
        IAdefense = 0;
      }
      let IAcs = opponentCharacter.spe;
      if (opponentCharacter.spe > 0 && opponentCharacter.spe < 1) {
        IAcs = 0;
      } else if (opponentCharacter.spe >= 1) {
        IAcs = 1;
      }
      let IApv = Math.min(Math.ceil((opponentCharacter.pv / opponentCharacter.pv_max) * 100 / 20) * 20, 100);

      // Constitution de l'état courant :
      // [Jcs, Jdefense, Jpv, Jaction, partieMode, IAcs, IAdefense, IApv]
      const currentState = [Jcs, Jdefense, Jpv, Jaction, partieMode, IAcs, IAdefense, IApv];
      console.log("État courant :", currentState);

      // Recherche dans l'historique en ignorant l'action du joueur (index 3)
      const similarData = findSimilarData(currentState, historicalData);

      // Prédiction de l'action probable du joueur
      const predictedAction = mostProbableAction(similarData);
      console.log("Action prédite :", predictedAction);
      opponentCharacter.next_choice = predictedAction;

      // Ajout du tour actuel à l'historique
      historicalData.push(currentState);
      saveHistoricalData(historicalData);

      // Exécution du tour de l'IA
      iaTurn(opponentCharacter, playerCharacter);

      // Passage aux tours suivants après un délai (mise à jour de l'UI, barres spéciales, etc.)
      setTimeout(() => {
        adversairepasser_tour();
        joueurpasser_tour();
        updateSpecialBar(playerCharacter, 'player-special-bar');
        updateSpecialBar(opponentCharacter, 'opponent-special-bar');
        updateUI();
      }, 1000);
    }




    //
    // 3. opponentDefense
    //
    function opponentDefense() {
      opponentCharacter.defense_bouton = 1;
      opponentCharacter.defense_droit = 4;
      // Soin basé sur 80% des dégâts subis
      const soin = Math.round(opponentCharacter.degats_subit * 0.8);
      opponentCharacter.pv += soin;
      addCombatLog(`${opponentCharacter.name} se défend de la dernière attaque de ${playerCharacter.name}.`, "#6699CC");
      scrollToBottom();
      handleAttack(opponentCharacter, playerCharacter, false);
    }

    //
    // 4. handleDefense
    //
    function handleDefense(character, opponent, isPlayer) {
      if (character.defense_droit === 0) {
        if (character.spe >= 0.1) {
          character.spe -= 0.1;
          character.defense_bouton = 1;
          character.defense_droit = 4;
          addCombatLog(`${character.name} se défend contre la prochaine attaque de ${opponent.name}.`, "#6699CC");
          if (isPlayer) {
            character.defense_partie += 1;
            character.last_action = 1;
            opponentTurn();
          }
        } else {
          addCombatLog(`${character.name} n'a pas assez d'énergie spéciale pour se défendre !`, "#6699CC");
          handleAttack(character, opponent, true);
        }
      } else {
        addCombatLog(`${character.name} ne peut pas se défendre avant dans ${character.defense_droit} tours.`, "#6699CC");
        if (isPlayer) handleAttack(character, opponent, true);
      }

      updateSpecialBar(playerCharacter, "player-special-bar");
      updateSpecialBar(opponentCharacter, "opponent-special-bar");
      updateUI();
    }

    //
    // 5. handleAttack
    //
    function handleAttack(attacker, defender, isPlayerAttacking) {
      // Gestion de l'augmentation du spe selon le personnage
      if (["Doudou", "Diva", "Cocobi"].includes(attacker.name)) {
        attacker.spe += 0.20;
        if (attacker.chargement2) attacker.spe -= 0.10;
      } else {
        attacker.spe += 0.25;
        if (attacker.chargement2) attacker.spe -= 0.125;
      }
      if (isPlayerAttacking) {
        specialAbility = attacker.spe;
        attacker.last_action = 0
      }
      if (isPlayerAttacking && attacker.spe < 0) {
        attacker.last_action = 2;
      }
      if (attacker.spe >= 1) attacker.spe = 1;

      const logColor = "#CC3333"; // couleur rouge brique pour l'attaque
      let damage;
      const combatLog = document.getElementById("combat-log");

      // Cas où l'attaquant est immobilisé
      if (attacker.immobilisation > 0) {
        damage = 0;
        addCombatLog(`${defender.name} a immobilisé ${attacker.name} ! Il ne peut donc pas attaquer.`, logColor);
      }
      // Cas où le défenseur utilise sa cape
      else if (defender.cape) {
        damage = 0;
        addCombatLog(`${defender.name} a utilisé une cape de l'ombre, ${attacker.name} ne l'a donc pas atteint !`, logColor);
      }
      else {
        // Calcul de la défense modifiée (entre 90% et 1.1 fois la défense)
        const defenseModifier = 0.9 + Math.random() * 0.2;
        const modifiedDefense = Math.round(defender.defense * defenseModifier);
        damage = Math.max(0, attacker.attaque - modifiedDefense);

        // Si le défenseur est en mode défense
        if (defender.defense_bouton === 1) {
          defender.defense_bouton = 0;
          damage = Math.round(attacker.attaque * 0.2);
        }

        // Mise à jour des PV
        defender.pv = Math.max(defender.pv - damage, 0);
        // Sauvegarde du dernier dégât subi pour d'éventuels soins en défense
        opponentCharacter.degats_subit = damage;

        // Affichage du message d'attaque
        if (isPlayerAttacking) {
          addCombatLog(`Vous attaquez et infligez ${damage} points de dégâts à ${defender.name}.`, logColor);
          document.getElementById("opponent-pv").textContent = `PV: ${defender.pv}`;
        } else {
          addCombatLog(`${attacker.name} attaque et inflige ${damage} points de dégâts.`, logColor);
          document.getElementById("player-pv").textContent = `PV: ${defender.pv}`;
        }

        if (isPlayerAttacking) {
          playerCharacter.degats_partie += damage;
          if (playerCharacter.spe >= 0.1) {
            playerCharacter.degats_partie_base += damage;
          }
        }
      }

      // Vérifier si le défenseur est vaincu
      if (defender.pv === 0) {
        const userData = getUserData();
        let perteTrophees = 0;

        if (isPlayerAttacking) {
          userData.victoires += 1;
          userData.trophees += 10;
          userData.fin_trophee = 10;
          if (userData.parties_weekend_test < 5) {
            userData.trophees -= 10;
          }
        } else {
          userData.defaites += 1;
          if (userData.trophees < 150) {
            perteTrophees = 1;
          } else if (userData.trophees <= 150) {
            perteTrophees = 3;
          } else if (userData.trophees <= 300) {
            perteTrophees = 5;
          } else if (userData.trophees <= 500) {
            perteTrophees = 8;
          } else if (userData.trophees <= 750) {
            perteTrophees = 10;
          } else {
            perteTrophees = 12;
          }
          if (userData.parties_weekend_test < 5) {
            perteTrophees = 0;
          }
          userData.trophees = Math.max(userData.trophees - perteTrophees, 0);
          saveUserData(userData);
        }

        // Calcul et application des récompenses
        let gain_XP = calculateXP(attacker, defender, isPlayerAttacking);
        let gain_argent = Math.round(gain_XP / 3);
        if (gain_XP < 20 && isPlayerAttacking) gain_XP = 20;
        if (userData.XP_jour >= 2500) gain_XP = 0;
        if (playerCharacter.xp2) gain_XP *= 2;
        if (playerCharacter.points2) gain_argent *= 2;
        userData.XP_jour += gain_XP;

        if (userData.Double_XP > 0) {
          gain_XP *= 2;
          userData.Double_XP -= 1;
        } else if (userData.Double_XP_acheté > 0) {
          userData.Double_XP_acheté -= 1;
          gain_XP *= 2;
        }
        if (userData.parties_weekend_test < 5) {
          gain_argent = 0;
          gain_XP = 0;
          userData.parties_weekend_test += 1;
          saveUserData(userData);
        }
        userData.pass_XP += gain_XP;
        saveUserData(userData);
        updateCharacterXP(userData, playerCharacter.name, gain_XP);
        userData.argent += gain_argent;

        // Affichage du résultat de la défaite ou de la victoire
        if (isPlayerAttacking) {
          combatLog.innerHTML += `<p>${defender.name} a été vaincu !</p>`;
          userData.gagnant = attacker.name;
          userData.fin_xp = gain_XP;
          userData.fin_argent = gain_argent;
        } else {
          combatLog.innerHTML += `<p>${attacker.name} vous a vaincu !</p>`;
          userData.gagnant = attacker.name;
          userData.fin_xp = gain_XP;
          userData.fin_argent = gain_argent;
          userData.fin_trophee = -perteTrophees;
        }
        saveUserData(userData);

        // Désactiver les boutons d'attaque et de capacité spéciale
        document.getElementById("attack-button").disabled = true;
        document.getElementById("special-button").disabled = true;

        // Gestion des quêtes (boucle sur les semaines et quests)
        for (let week = 1; week <= 5; week++) {
          if (userData[`semaine${week}`]) {
            for (let quest = 1; quest <= 5; quest++) {
              const questKey = `Semaine${week}_${quest}`;
              const questCompletedKey = `${questKey}_completed`;
              const questTypeKey = `${questKey}_type`;
              const questCurrentKey = `${questKey}_current`;
              const questCharacter = `${questKey}_character`;
              if (!userData[questCompletedKey]) {
                switch (userData[questTypeKey]) {
                  case "VCS":
                    if (isPlayerAttacking) userData[questCurrentKey] += 1;
                    break;
                  case "CC":
                    userData[questCurrentKey] += playerCharacter.capacite_partie;
                    break;
                  case "VPCS":
                    if (isPlayerAttacking && playerCharacter.name === userData[questCharacter]) userData[questCurrentKey] += 1;
                    break;
                  case "DSC":
                    userData[questCurrentKey] += playerCharacter.degats_partie;
                    break;
                  case "O":
                    userData[questCurrentKey] += playerCharacter.objets_partie;
                    break;
                  case "DC":
                    userData[questCurrentKey] += playerCharacter.defense_partie;
                    break;
                }
                saveUserData(userData);
              }
            }
          }
        }

        // Mise à jour des quêtes principales
        if (userData.quete1_type === "victoire_classique" && playerCharacter.name === userData.quete1_character && isPlayerAttacking) {
          userData.quete1_current += 1;
        } else if (userData.quete1_type === "dommages_classique") {
          userData.quete1_current += playerCharacter.degats_partie;
        } else if (userData.quete1_type === "objets_total") {
          userData.quete1_current += playerCharacter.objets_partie;
        } else if (userData.quete1_type === "defense_classique") {
          userData.quete1_current += playerCharacter.defense_partie;
        }

        if (userData.quete2_type === "victoire_classique" && playerCharacter.name === userData.quete2_character && isPlayerAttacking) {
          userData.quete2_current += 1;
        } else if (userData.quete2_type === "dommages_classique") {
          userData.quete2_current += playerCharacter.degats_partie;
        } else if (userData.quete2_type === "objets_total") {
          userData.quete2_current += playerCharacter.objets_partie;
        } else if (userData.quete2_type === "defense_classique") {
          userData.quete2_current += playerCharacter.defense_partie;
        }

        if (userData.quete3_type === "victoire_classique" && playerCharacter.name === userData.quete3_character && isPlayerAttacking) {
          userData.quete3_current += 1;
        } else if (userData.quete3_type === "dommages_classique") {
          userData.quete3_current += playerCharacter.degats_partie;
        } else if (userData.quete3_type === "objets_total") {
          userData.quete3_current += playerCharacter.objets_partie;
        } else if (userData.quete3_type === "defense_classique") {
          userData.quete3_current += playerCharacter.defense_partie;
        }
        saveUserData(userData);

        updateCharacterXP(userData, playerCharacter.name, gain_XP);
        userData.argent += gain_argent;
        checkAndDisplayCharacterUnlock(userData);
        saveUserData(userData);

        // Fin de partie après 2 secondes
        setTimeout(() => {
          localStorage.removeItem("historicalData_weekend");
          sessionStorage.removeItem("playerCharacter");
          sessionStorage.removeItem("opponentCharacter");
          window.location.href = "fin_partie.html";
        }, 2000);
      } else if (isPlayerAttacking) {
        // Si le défenseur n'est pas vaincu, on passe au tour adverse
        opponentTurn();
        updateSpecialBar(playerCharacter, "player-special-bar");
        updateSpecialBar(opponentCharacter, "opponent-special-bar");
        updateUI();
      }

      updateSpecialButton();
      scrollToBottom();
    }

    function calculateXP(attacker, defender, isPlayerAttacking) {
      let userData = getUserData();
      let niveau = Number(userData[attacker.name + "_Level"]) * 0.1;
      if (isPlayerAttacking) {
        let joueur_pv = attacker.pv;
        let joueur_pv_base = attacker.pv_max;
        return Math.round((2 * (joueur_pv / joueur_pv_base) * 100) * (1 / (1 + niveau)));
      } else if (userData.XP_jour >= 2500) {
        return 0;
      } else {
        return Math.round(20 - (2 * (niveau - 1)));
      }
    }

    function updateCharacterXP(userData, characterName, xp) {
      const key = `${characterName}_XP`;
      if (userData.hasOwnProperty(key)) {
        userData[key] += xp;
        saveUserData(userData);
      }
    }


    function scrollToBottom() {
      const combatLog = document.getElementById('combat-log');
      combatLog.scrollTop = combatLog.scrollHeight;
    }
    // Fonction pour vérifier et afficher le déblocage d'un nouveau personnage
    function checkAndDisplayCharacterUnlock(userData) {
      const rewardPals = [
        10, 20, 30, 40, 60, 80, 100, 120, 150, 180, 220, 260, 300, 350, 400,
        460, 520, 580, 650, 720, 800, 880, 970, 1060, 1150, 1250, 1350, 1460,
        1570, 1690
      ];

      // Initialiser les paliers de récompense si non définis
      userData.palier_recompense = userData.palier_recompense || [];
      userData.recompense = userData.recompense || 0;
      userData.perso_recompense = userData.perso_recompense || 0;

      let newPalsReached = rewardPals.filter(
        (trophy) => userData.trophees >= trophy && !userData.palier_recompense.includes(trophy)
      );

      if (newPalsReached.length > 0) {
        userData.palier_recompense.push(...newPalsReached);
        userData.recompense += newPalsReached.length;

        // Ajouter un personnage récompense tous les 10 nouveaux paliers atteints
        if (userData.palier_recompense.length % 10 === 0) {
          userData.perso_recompense++;
        }

        saveUserData(userData);
      }
    }

    function sauvegarderPartie(playerCharacter, opponentCharacter) {
      const sauvegarde = {
        playerCharacter: {
          name: playerCharacter.name,
          pv: playerCharacter.pv,
          pv_max: playerCharacter.pv_max,
          attaque: playerCharacter.attaque,
          defense: playerCharacter.defense,
          spe: playerCharacter.spe,
          attaque_originale: playerCharacter.attaque_originale,
          defense_originale: playerCharacter.defense_originale,
          perte_att: playerCharacter.perte_att,
          Oiseaudefense: playerCharacter.Oiseaudefense,
          perte_defense_colorina: playerCharacter.perte_defense_colorina,
          amulette_soin: playerCharacter.amulette_soin,
          attaque_epee: playerCharacter.attaque_epee,
          attaque_elixir: playerCharacter.attaque_elixir,
          armure: playerCharacter.armure,
          degats_partie: playerCharacter.degats_partie,
          objets_partie: playerCharacter.objets_partie,
          capacite_partie: playerCharacter.capacite_partie,
          degats_partie_base: playerCharacter.degats_partie_base,
          objets_soin: playerCharacter.objets_soin,
          defense_bouton: playerCharacter.defense_bouton,
          defense_droit: playerCharacter.defense_droit,
          defense_solide: playerCharacter.defense_solide,
          defense_partie: playerCharacter.defense_partie,
          immobilisation: playerCharacter.immobilisation || 0,
          sboonie_attaque: playerCharacter.sboonie_attaque || 0,
          poulpy_att: playerCharacter.poulpy_att || 0,
          objets_utilise: playerCharacter.objets_utilise || 0,
          inventaire_objets: playerCharacter.inventaire_objets || false,
          amuletteUses: playerCharacter.amuletteUses || 0,
          armureUses: playerCharacter.armureUses || 0,
          tour: playerCharacter.tour || 1,
          cape: playerCharacter.cape || false,
          capeUses: playerCharacter.capeUses || 0,
          crystalUses: playerCharacter.crystalUses || 0,
          inconnu_super: playerCharacter.inconnu_super || 0,
          last_action: playerCharacter.last_action || 0,
          chargement2: playerCharacter.chargement2,
          nodefense: playerCharacter.nodefense,
          points2: playerCharacter.points2,
          xp2: playerCharacter.xp2,
          noobject: playerCharacter.noobject,
          
        },
        opponentCharacter: {
          name: opponentCharacter.name,
          pv: opponentCharacter.pv,
          pv_max: opponentCharacter.pv_max,
          attaque: opponentCharacter.attaque,
          defense: opponentCharacter.defense,
          spe: opponentCharacter.spe,
          attaque_originale: opponentCharacter.attaque_originale,
          defense_originale: opponentCharacter.defense_originale,
          perte_att: opponentCharacter.perte_att || 0,
          Oiseaudefense: opponentCharacter.Oiseaudefense || 0,
          perte_defense_colorina: opponentCharacter.perte_defense_colorina || 0,
          pv_maximum: opponentCharacter.pv,
          immobilisation: opponentCharacter.immobilisation || 0,
          defense_bouton: opponentCharacter.defense_bouton || 0,
          defense_droit: opponentCharacter.defense_droit || 0,
          sboonie_attaque: opponentCharacter.sboonie_attaque || 0,
          poulpy_att: opponentCharacter.poulpy_att || 0,
          degats_subit: opponentCharacter.degats_subit || 0,
          inconnu_super: opponentCharacter.inconnu_super || 0,
          next_choice: opponentCharacter.next_choice || "0",
          chargement2: opponentCharacter.chargement2,
          nodefense: opponentCharacter.nodefense,
        }
      };

      localStorage.setItem("savepartie_weekend", JSON.stringify(sauvegarde));
    }

    
    userData.partie_commencee = true;
    saveUserData(userData);

  </script>
</body>

</html>