<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <title>Combat</title>
  <script src="quest.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: url('background.jpg') no-repeat center center fixed;
      background-size: cover;
      color: #333;
      transition: background-color 0.3s, color 0.3s;
      position: relative;
      overflow: hidden;
      /* Empêche le défilement du body */
    }

    .content {
      overflow-y: auto;
      /* Permet le défilement vertical */
      height: 100vh;
      /* Occupe toute la hauteur de la fenêtre */
      -webkit-overflow-scrolling: touch;
      /* Assure le défilement fluide sur les appareils tactiles */
    }

    .top-bar {
      height: 100px;
      background-color: #d1d1d6;
      display: flex;
      align-items: center;
      padding: 10px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      justify-content: space-between;
    }

    .header-info {
      display: flex;
      flex-direction: column;
      margin: 0 20px;
    }

    .header-info h3,
    .header-info p {
      margin: 0;
      padding: 0;
    }

    #player-money {
      display: none;
    }

    .combat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 20px;
      padding-bottom: 20px;
      box-sizing: border-box;
      margin: 100;
    }

    #combat-log {
      width: 100%;
      padding: 10px;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      height: 300px;
      overflow-y: auto;
    }

    .combat-actions-wrapper {
      position: fixed;
      bottom: 0px;
      width: 100%;
      background-color: #fff;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
      padding-top: 10px;
    }

    body.web-app .combat-actions-wrapper {
      bottom: 50px;
    }

    .combat-actions {
      display: flex;
      justify-content: space-around;
    }

    .combat-actions button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      padding: 0;
      font-size: 0;
      line-height: 0;
      background-color: transparent;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.3s;
    }

    .combat-actions button#defense-button {
      background-image: url('defense.png');
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
    }

    .combat-actions button#attack-button {
      background-image: url('attaque.png');
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
    }

    .combat-actions button#special-button {
      background-image: url('special.png');
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
    }

    .combat-actions button#special-button.bright {
      filter: brightness(1.5) drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));
    }

    .combat-actions button#special-button.grow {
      transform: scale(1.1);
    }

    .combat-actions button#items-button {
      background-image: url('inventaire.png');
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
    }

    #item-selection {
      display: none;
      text-align: center;
      margin-top: 10px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      max-height: 300px;
      overflow-y: auto;
    }

    #item-selection button {
      display: block;
      width: 100%;
      max-width: 200px;
      padding: 15px;
      margin: 10px auto;
      font-size: 18px;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background-color: #4CAF50;
      color: white;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      transition: background-color 0.3s, transform 0.3s;
    }

    #item-selection button:hover {
      background-color: #45a049;
      transform: scale(1.05);
    }

    #item-selection button:active {
      background-color: #388e3c;
      transform: scale(1.02);
    }

    /* Styles pour le mode sombre */
    @media (prefers-color-scheme: dark) {
      body {
        background-color: #000;
        color: #e0e0e0;
      }

      .top-bar {
        background-color: #333;
      }

      .combat-actions-wrapper {
        background-color: #333;
      }

      .combat-actions button {
        background-color: #333;
        color: #e0e0e0;
      }

      .combat-actions button:hover {
        background-color: #333;
      }

      #combat-log {
        background-color: #333;
        border-color: #444;
        color: #e0e0e0;
      }

      #item-selection {
        background-color: #333;
        color: #e0e0e0;
        border-color: #444;
      }

      #item-selection button {
        background-color: #444;
        color: #e0e0e0;
        border-color: #555;
      }

      #item-selection button:hover {
        background-color: #555;
      }
    }

    .special-bar {
      width: 100%;
      background-color: #ddd;
      border-radius: 5px;
      height: 5px;
      overflow: hidden;
      margin: 5px 0;
    }

    .special-fill {
      height: 100%;
      width: 0;
      background-color: #4CAF50;
      transition: width 0.3s ease-in-out;
    }

    /* Masquer les barres de défilement */
    .content::-webkit-scrollbar {
      display: none;
    }

    .content {
      scrollbar-width: none;
    }

    .content {
      -ms-overflow-style: none;
    }
  </style>
  <style>
    @media (min-width: 1024px) {
      .combat-actions-wrapper {
        position: absolute;
        bottom: 0;
      }
    }
  </style>
</head>

<body>
  <div class="content">
    <div class="top-bar">
      <div class="header-info">
        <h3 id="player-name"></h3>
        <p id="player-pv"></p>
        <div id="player-special-bar" class="special-bar">
          <div id="player-special-fill" class="special-fill"></div>
        </div>
        <p id="player-attack"></p>
        <p id="player-defense"></p>
      </div>
      <div class="header-info">
        <h3 id="opponent-name"></h3>
        <p id="opponent-pv"></p>
        <div id="opponent-special-bar" class="special-bar">
          <div id="opponent-special-fill" class="special-fill"></div>
        </div>
        <p id="opponent-attack"></p>
        <p id="opponent-defense"></p>
      </div>
    </div>

    <div class="combat-container">
      <div id="combat-log"></div>
    </div>

    <div class="combat-actions-wrapper">
      <div class="combat-actions">
        <button id="attack-button" onclick="handleAttack(playerCharacter, opponentCharacter, true);"></button>
        <button id="defense-button" onclick="handleDefense(playerCharacter, opponentCharacter, true);"></button>
        <button id="special-button" onclick="useSpecialAbility(playerCharacter, opponentCharacter, true);"></button>
        <button id="items-button" onclick="showItemSelection()"></button>
      </div>
      <div id="item-selection">
        <button onclick="hideItemSelection()">Annuler</button>
      </div>
    </div>
  </div>
  <script type="module">
    // Importation des modules Firebase
    import {initializeApp} from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
    import {getPerformance} from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-performance.js';

    // Configuration Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyAwIIKfoYwdtFD63yKhVggZOAnooQion-M",
      authDomain: "willy0s-parallel-arena.firebaseapp.com",
      databaseURL: "https://willy0s-parallel-arena-default-rtdb.firebaseio.com",
      projectId: "willy0s-parallel-arena",
      storageBucket: "willy0s-parallel-arena.appspot.com",
      messagingSenderId: "683284732830",
      appId: "1:683284732830:web:ef7fb4cf1c88f73eead48f",
      measurementId: "G-85B8R4NKNM"
    };

    // Initialisation de Firebase
    const app = initializeApp(firebaseConfig);

    // Initialisation de Firebase Performance Monitoring
    const perf = getPerformance(app);
    if ('PerformanceObserver' in window) {
      // Créer un observateur pour les entrées de type "paint" (pour FCP)
      const paintObserver = new PerformanceObserver((list) => {
        const entries = list.getEntriesByName('first-contentful-paint');
        if (entries.length > 0) {
          const fcp = entries[0].startTime;
          console.log('First Contentful Paint (FCP):', fcp, 'ms');
        }
      });

      // Observer les événements de type "paint"
      paintObserver.observe({type: 'paint', buffered: true});

      // Créer un observateur pour les entrées de type "first-input" (pour FID)
      const fidObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach((entry) => {
          if (entry.entryType === 'first-input') {
            const fid = entry.processingStart - entry.startTime;
            console.log('First Input Delay (FID):', fid, 'ms');
          }
        });
      });

      // Observer les événements de type "first-input"
      fidObserver.observe({type: 'first-input', buffered: true});
    }
  </script>
  <script>
    // Déclaration globale des variables (elles seront accessibles partout)
    let playerCharacter = null;
    let opponentCharacter = null;
    let specialAbility = 0;

    // Détection du mode d'affichage (standalone ou non)
    if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true) {
      document.body.classList.add('web-app');
    } else {
      document.body.classList.add('normal-app');
    }

    // Récupère les données utilisateur depuis localStorage
    function getUserData() {
      let userData = localStorage.getItem('userData');
      if (userData) {
        try {
          userData = JSON.parse(userData);
        } catch (e) {
          console.error('Erreur lors du parsing de userData :', e);
          userData = {};
        }
        return userData;
      }
      return {}; // Retourne un objet vide si aucune donnée n'est trouvée
    }

    const userData = getUserData();

    // Sauvegarde les données utilisateur dans localStorage
    function saveUserData(userData) {
      localStorage.setItem('userData', JSON.stringify(userData));
    }

    // Chargement de la sauvegarde de partie depuis localStorage
    let sauvegarde = null;
    try {
      sauvegarde = JSON.parse(localStorage.getItem("savepartie"));
    } catch (e) {
      console.error('Erreur lors du parsing de la sauvegarde :', e);
    }
    if (sauvegarde) {
      console.log('Sauvegarde trouvée :', sauvegarde);
    }

    // Fonction qui charge les personnages depuis la sauvegarde
    function chargerPartie() {
      const sauvegardeLocal = JSON.parse(localStorage.getItem("savepartie"));
      if (!sauvegardeLocal) {
        console.warn("Aucune sauvegarde trouvée.");
        return;
      }
      // Affectation directe des objets sauvegardés aux variables globales
      playerCharacter = sauvegardeLocal.playerCharacter;
      opponentCharacter = sauvegardeLocal.opponentCharacter;

      console.log("Partie chargée avec succès !");
      updateUI(); // Mise à jour de l'interface après chargement
    }

    // Si une partie a déjà commencé et qu'une sauvegarde existe, on la charge
    if (userData.partie_commencee && sauvegarde) {
      chargerPartie();
    } else {
      // Sinon, on initialise les personnages à partir des données stockées en sessionStorage

      // Récupération et initialisation du personnage du joueur
      const storedPlayer = sessionStorage.getItem('playerCharacter');
      if (storedPlayer) {
        playerCharacter = JSON.parse(storedPlayer);

        // Initialisation des nouvelles propriétés
        playerCharacter.perte_att = 0;
        playerCharacter.Oiseaudefense = 0;
        playerCharacter.perte_defense_colorina = 0;
        playerCharacter.pv_maximum = playerCharacter.pv;
        playerCharacter.amulette_soin = 0;
        playerCharacter.attaque_epee = 0;
        playerCharacter.attaque_elixir = 0;
        playerCharacter.armure = 0;
        playerCharacter.degats_partie = 0;
        playerCharacter.objets_partie = 0;
        playerCharacter.capacite_partie = 0;
        playerCharacter.degats_partie_base = 0;
        playerCharacter.objets_soin = 0;
        playerCharacter.defense_bouton = 0;
        playerCharacter.defense_droit = 0;
        playerCharacter.defense_solide = 0;
        playerCharacter.defense_partie = 0;
        playerCharacter.immobilisation = 0;
        playerCharacter.sboonie_attaque = 0;
        playerCharacter.poulpy_att = 0;
        playerCharacter.objets_utilise = 0;
        playerCharacter.inventaire_objets = false;
        playerCharacter.amuletteUses = 0;
        playerCharacter.armureUses = 0;
        playerCharacter.tour = 1;
        playerCharacter.cape = false;
        playerCharacter.capeUses = 0;
        playerCharacter.crystalUses = 0;
        playerCharacter.inconnu_super = 0;
        playerCharacter.last_action = 0;
      } else {
        // Rediriger vers index.html si les données du joueur ne sont pas trouvées
        window.location.href = 'index.html';
      }

      // Récupération et initialisation du personnage adverse
      const storedOpponent = sessionStorage.getItem('opponentCharacter');
      if (storedOpponent) {
        opponentCharacter = JSON.parse(storedOpponent);

        opponentCharacter.perte_att = 0;
        opponentCharacter.Oiseaudefense = 0;
        opponentCharacter.perte_defense_colorina = 0;
        opponentCharacter.pv_maximum = opponentCharacter.pv;
        opponentCharacter.immobilisation = 0;
        opponentCharacter.defense_bouton = 0;
        opponentCharacter.defense_droit = 0;
        opponentCharacter.sboonie_attaque = 0;
        opponentCharacter.poulpy_att = 0;
        opponentCharacter.degats_subit = 0;
        opponentCharacter.inconnu_super = 0;
        opponentCharacter.next_choice = "0";
      } else {
        // Rediriger vers index.html si les données de l'adversaire ne sont pas trouvées
        window.location.href = 'index.html';
      }
    }

    console.log('Player Character :', playerCharacter);
    console.log('Opponent Character :', opponentCharacter);

    // Empêche le retour en arrière dans l'historique du navigateur
    history.replaceState(null, null, window.location.href);

    console.log("good");

    // Initialisation de la capacité spéciale (on suppose que playerCharacter.spe existe)
    specialAbility = playerCharacter.spe || 0;

    // Mise à jour de l'interface utilisateur pour le joueur
    if (document.getElementById('player-name')) {
      document.getElementById('player-name').textContent = playerCharacter.name;
    }
    if (document.getElementById('player-pv')) {
      document.getElementById('player-pv').textContent = `PV: ${playerCharacter.pv}`;
    }

    // Mise à jour de l'interface utilisateur pour l'adversaire
    if (document.getElementById('opponent-name')) {
      document.getElementById('opponent-name').textContent = opponentCharacter.name;
    }
    if (document.getElementById('opponent-pv')) {
      document.getElementById('opponent-pv').textContent = `PV: ${opponentCharacter.pv}`;
    }

    // Fonction qui met à jour la barre de capacité spéciale
    function updateSpecialBar(character, elementId) {
      const specialBar = document.getElementById(elementId);
      if (!specialBar) return;
      const fillElement = specialBar.querySelector('.special-fill');
      if (!fillElement) return;
      const maxSpecialAbility = 1; // Valeur maximale de la capacité spéciale
      const widthPercentage = (character.spe / maxSpecialAbility) * 100;
      fillElement.style.width = `${widthPercentage}%`;
    }

    // Fonction qui met à jour l'interface globale (PV, noms, barres spéciales)
    function updateUI() {
      playerCharacter.pv = Math.round(playerCharacter.pv);
      opponentCharacter.pv = Math.round(opponentCharacter.pv);

      if (document.getElementById('player-name')) {
        document.getElementById('player-name').textContent = playerCharacter.name;
      }
      if (document.getElementById('player-pv')) {
        document.getElementById('player-pv').textContent = `PV: ${playerCharacter.pv}`;
      }
      updateSpecialBar(playerCharacter, 'player-special-bar');

      if (document.getElementById('opponent-name')) {
        document.getElementById('opponent-name').textContent = opponentCharacter.name;
      }
      if (document.getElementById('opponent-pv')) {
        document.getElementById('opponent-pv').textContent = `PV: ${opponentCharacter.pv}`;
      }
      updateSpecialBar(opponentCharacter, 'opponent-special-bar');
    }
    updateUI();

    // Fonction qui met à jour l'état du bouton de capacité spéciale
    function updateSpecialButton() {
      const specialButton = document.getElementById('special-button');
      if (!specialButton) return;
      const maxSpecialAbility = 1; // Valeur maximale

      if (specialAbility >= maxSpecialAbility) {
        specialButton.classList.add('bright');
        specialButton.classList.add('grow'); // Pour agrandir le bouton
        specialButton.textContent = 'Capacité spéciale';
      } else {
        specialButton.classList.remove('bright');
        specialButton.classList.remove('grow');
        specialButton.textContent = `${specialAbility.toFixed(1)} / 1`;
      }
    }
    updateSpecialButton();



    function adversairepasser_tour() {
      updateSpecialBar(opponentCharacter, 'opponent-special-bar');
      updateUI();
      if (opponentCharacter.inconnu_super >= 1) {
        opponentCharacter.inconnu_super -= 1;
      }
      if (opponentCharacter.immobilisation >= 1) {
        opponentCharacter.immobilisation -= 1;
      }
      if (opponentCharacter.defense_droit > 0) {
        opponentCharacter.defense_droit -= 1;
      }
      if (opponentCharacter.perte_att > 0) {
        opponentCharacter.perte_att -= 1;
        if (opponentCharacter.perte_att == 0) {
          opponentCharacter.attaque = Math.round(opponentCharacter.attaque / 0.75);
        }
      }
      if (opponentCharacter.poulpy_att > 0) {
        opponentCharacter.poulpy_att -= 1;
        if (opponentCharacter.poulpy_att == 0) {
          opponentCharacter.defense = Math.round(opponentCharacter.defense / 0.85);
        }
      }
      if (opponentCharacter.Oiseaudefense > 0) {
        opponentCharacter.Oiseaudefense -= 1;
        if (opponentCharacter.Oiseaudefense == 0) {
          opponentCharacter.defense -= 20;
        }
      }
      if (opponentCharacter.perte_defense_colorina > 0) {
        opponentCharacter.perte_defense_colorina -= 1;
        if (opponentCharacter.perte_defense_colorina == 0) {
          opponentCharacter.defense = Math.round(opponentCharacter.defense / 0.85);
        }
      }
      if (opponentCharacter.sboonie_attaque > 0) {
        opponentCharacter.sboonie_attaque -= 1;
        if (opponentCharacter.sboonie_attaque == 0) {
          opponentCharacter.attaque = Math.round(opponentCharacter.attaque / 0.85);
        }
      }
      sauvegarderPartie(playerCharacter, opponentCharacter);
    }


    function joueurpasser_tour() {
      updateSpecialBar(playerCharacter, 'player-special-bar');
      updateUI();
      playerCharacter.tour += 1;
      playerCharacter.inventaire_objets = false;
      playerCharacter.objets_utilise = 0;
      if (playerCharacter.inconnu_super >= 1) {
        playerCharacter.inconnu_super -= 1;
      }
      if (playerCharacter.cape) {
        playerCharacter.cape = false;
      }
      if (playerCharacter.immobilisation >= 1) {
        playerCharacter.immobilisation -= 1;
      }
      if (playerCharacter.amulette_soin > 0) {
        playerCharacter.pv = Math.round(playerCharacter.pv + (playerCharacter.pv_maximum * 0.02));
      }
      if (playerCharacter.defense_droit > 0) {
        playerCharacter.defense_droit -= 1;
      }
      if (playerCharacter.perte_att > 0) {
        playerCharacter.perte_att -= 1;
        if (playerCharacter.perte_att == 0) {
          playerCharacter.attaque = Math.round(playerCharacter.attaque / 0.75);
        }
      }
      if (playerCharacter.poulpy_att > 0) {
        playerCharacter.poulpy_att -= 1;
        if (playerCharacter.poulpy_att == 0) {
          playerCharacter.defense = Math.round(playerCharacter.defense / 0.85);
        }
      }
      if (playerCharacter.Oiseaudefense > 0) {
        playerCharacter.Oiseaudefense -= 1;
        if (playerCharacter.Oiseaudefense == 0) {
          playerCharacter.defense -= 20;
        }
      }
      if (playerCharacter.perte_defense_colorina > 0) {
        playerCharacter.perte_defense_colorina -= 1;
        if (playerCharacter.perte_defense_colorina == 0) {
          playerCharacter.defense = Math.round(playerCharacter.defense / 0.85);
        }
      }
      if (playerCharacter.sboonie_attaque > 0) {
        playerCharacter.sboonie_attaque -= 1;
        if (playerCharacter.sboonie_attaque == 0) {
          playerCharacter.attaque = Math.round(playerCharacter.attaque / 0.85);
        }
      }
      sauvegarderPartie(playerCharacter, opponentCharacter);

    }

    function showItemSelection() {
      const itemSelectionDiv = document.getElementById('item-selection');
      itemSelectionDiv.style.display = 'block';

      // Clear previous items
      itemSelectionDiv.innerHTML = '<h3>Choisissez un objet à utiliser</h3>';

      const userData = getUserData();
      const availableItems = [];

      // Vérifier si l'amulette de régénération a déjà été utilisée
      if (userData.crystal_acheté > 0 && playerCharacter.crystalUses < 2) {
        availableItems.push({
          name: 'Crystal de renouveau', count: userData.crystal_acheté
        });
      }
      if (userData.bouclier_solide_acheté > 0) {
        availableItems.push({name: 'Bouclier solide', count: userData.bouclier_solide_acheté});
      }
      if (userData.Cape_acheté > 0 && playerCharacter.capeUses < 2) {
        availableItems.push({name: "Cape de l'ombre", count: userData.Cape_acheté});
      }
      if (userData.Potion_de_Santé_acheté > 0) {
        availableItems.push({name: 'Potion de Santé', count: userData.Potion_de_Santé_acheté});
      }
      if (userData.armure_fer_acheté > 0 && playerCharacter.armureUses < 2) {
        // L'armure ne s'affiche plus si elle a été utilisée deux fois
        availableItems.push({name: 'Armure de Fer', count: userData.armure_fer_acheté});
      }
      if (userData.Amulette_de_Régénération_acheté > 0 && playerCharacter.amuletteUses < 1) {
        // L'amulette ne s'affiche plus si elle a été utilisée une fois
        availableItems.push({name: 'Amulette de Régénération', count: userData.Amulette_de_Régénération_acheté});
      }
      if (userData.epee_tranchante_acheté > 0) {
        availableItems.push({name: 'Épée Tranchante', count: userData.epee_tranchante_acheté});
      }
      if (userData.elixir_puissance_acheté > 0) {
        availableItems.push({name: 'Elixir de Puissance', count: userData.elixir_puissance_acheté});
      }


      // Si aucun objet n'a été utilisé
      if (playerCharacter.objets_utilise === 0) {
        // Si inventaire_objets est à false, on sélectionne 3 objets aléatoirement
        if (!playerCharacter.inventaire_objets) {
          playerCharacter.selectedItems = [];

          // Mélanger les items disponibles et en sélectionner 3
          const shuffledItems = availableItems.sort(() => 0.5 - Math.random());
          playerCharacter.selectedItems = shuffledItems.slice(0, 3);

          // Passer inventaire_objets à true pour se souvenir de la sélection
          playerCharacter.inventaire_objets = true;
        }

        // Afficher les 3 objets sélectionnés
        playerCharacter.selectedItems.forEach(item => {
          const itemButton = document.createElement('button');
          itemButton.textContent = `${item.name} (${item.count})`;
          itemButton.onclick = function () {useItem(item.name);};
          itemSelectionDiv.appendChild(itemButton);
        });

        // Ajouter le bouton Annuler
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Annuler';
        cancelButton.onclick = hideItemSelection;
        itemSelectionDiv.appendChild(cancelButton);

      } else if (playerCharacter.objets_utilise !== 0) {
        // Si des objets ont déjà été utilisés, proposer uniquement le bouton Annuler
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Annuler';
        cancelButton.onclick = hideItemSelection;
        itemSelectionDiv.appendChild(cancelButton);
      }
    }

    function hideItemSelection() {
      document.getElementById('item-selection').style.display = 'none';
    }

    function useItem(itemName) {
      const userData = getUserData();
      playerCharacter.objets_utilise = 1;
      switch (itemName) {
        case 'Crystal de renouveau':
          userData.crystal_acheté -= 1;
          playerCharacter.crystalUses += 1;
          playerCharacter.spe += 0.8;
          if (playerCharacter.spe > 1) {
            playerCharacter.spe = 1;
          }
          saveUserData(userData);
          updateUI();
          break;
        case "Cape de l'ombre":
          userData.Cape_acheté -= 1;
          playerCharacter.capeUses += 1;
          playerCharacter.cape = true;
          saveUserData(userData);
          break;
        case 'Potion de Santé':
          userData.Potion_de_Santé_acheté -= 1;
          playerCharacter.pv += 1100;

          if (playerCharacter.pv > playerCharacter.pv_maximum) {
            playerCharacter.pv = playerCharacter.pv_maximum;
          }
          playerCharacter.objets_partie += 1;
          playerCharacter.objets_soin += 1;
          saveUserData(userData);
          break;

        case 'Amulette de Régénération':
          userData.Amulette_de_Régénération_acheté -= 1;
          // Amulette soin devient un effet permanent de régénération
          playerCharacter.amuletteUses += 1;
          playerCharacter.amulette_soin = 1; // On garde une régénération constante
          playerCharacter.objets_partie += 1;
          playerCharacter.objets_soin += 1;
          saveUserData(userData);
          break;

        case 'Épée Tranchante':
          userData.epee_tranchante_acheté -= 1;
          // Appliquer une augmentation permanente de l'attaque
          playerCharacter.attaque = Math.round(playerCharacter.attaque * 1.05); // Moins fort mais permanent
          playerCharacter.objets_partie += 1;
          saveUserData(userData);
          break;

        case 'Elixir de Puissance':
          userData.elixir_puissance_acheté -= 1;
          // L'effet reste permanent avec une augmentation modérée
          playerCharacter.attaque += 50; // Réduction de l'effet initial mais permanent
          playerCharacter.objets_partie += 1;
          saveUserData(userData);
          break;

        case 'Armure de Fer':
          userData.armure_fer_acheté -= 1;
          // Réduire l'attaque de l'adversaire de façon permanente
          playerCharacter.armureUses += 1;
          opponentCharacter.attaque = Math.round(opponentCharacter.attaque * 0.90); // Moins d'effet mais permanent
          playerCharacter.objets_partie += 1;
          saveUserData(userData);
          break;

        case 'Bouclier solide':
          userData.bouclier_solide_acheté -= 1;
          // Appliquer une augmentation permanente de la défense
          playerCharacter.defense += 15; // Réduit l'effet initial mais permanent
          playerCharacter.objets_partie += 1;
          saveUserData(userData);
          break;

        default:
          console.log('Objet non reconnu');
      }

      // Mettre à jour l'interface utilisateur

      document.getElementById('player-pv').textContent = `PV: ${playerCharacter.pv}`;

      // Masquer la sélection des objets
      hideItemSelection();

      // Ajoute une entrée dans le journal de combat
      const combatLog = document.getElementById('combat-log');
      const itemLogEntry = document.createElement('p');
      itemLogEntry.textContent = `${itemName} utilisé !`;
      combatLog.appendChild(itemLogEntry);

      scrollToBottom(); // Assurez-vous que la vue défile vers le bas
    }


    function useSpecialAbility(character, opponent, isPlayer) {

      if (character.spe >= 1) {
        // Décrémente la quantité de la capacité spéciale utilisée
        character.spe -= 1;
        if (isPlayer) {
          specialAbility -= 1;
          character.capacite_partie += 1;
          character.last_action = 2;
        }


        let specialLogMessage = "";
        if (character.immobilisation >= 1) {
          specialLogMessage = `${character.name} utilise sa capacité spéciale ! Mais ${opponent.name} l'a immobilisé, donc l'attaque échoue et rien ne se passe.`;
          opponent.pv -= 0;

          // Ajouter le message au journal
          const combatLog = document.getElementById('combat-log');
          const specialLogEntry = document.createElement('p');
          specialLogEntry.textContent = specialLogMessage;
          specialLogEntry.style.color = "#9966CC";  // Couleur pour la capacité spéciale
          combatLog.appendChild(specialLogEntry);
        } else if (opponent.defense_bouton === 1) {
          opponent.defense_bouton = 0;
          specialLogMessage = `${character.name} utilise sa capacité spéciale ! Mais ${opponent.name} l'en empêche, donc l'attaque échoue et rien ne se passe.`;
          opponent.pv -= 0;

          // Ajouter le message au journal
          const combatLogdefense = document.getElementById('combat-log');
          const specialLogEntry = document.createElement('p');
          specialLogEntry.textContent = specialLogMessage;
          specialLogEntry.style.color = "#9966CC";  // Couleur pour la capacité spéciale
          combatLogdefense.appendChild(specialLogEntry);
        } else if (character.inconnu_super >= 1) {
          specialLogMessage = `${character.name} ne peut pas utiliser sa capacité spéciale, car ${character.name} la bloqué pour encore ${character.inconnu_super} tours.`;
          character.spe += 1;
          const combatLogInco = document.getElementById('combat-log');
          const specialLogEntryInco = document.createElement('p');
          specialLogEntryInco.textContent = specialLogMessage;
          specialLogEntryInco.style.color = "#9966CC";  // Couleur pour la capacité spéciale
          combatLogInco.appendChild(specialLogEntryInco);
          handleAttack(character, opponent, isPlayer);
        } else {
          switch (character.name) {
            case "Diva":
              opponent.attaque *= 0.75;
              character.spe -= 0.25;
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! L'attaque de ${opponent.name} est réduite à ${Math.round(opponent.attaque.toFixed(2))} pour les 3 prochains tours.`;
              opponent.perte_att += 3;
              if (!isPlayer) {
                opponent.perte_att += 1;
              }

              // Ajouter le message au journal
              const combatLogDiva = document.getElementById('combat-log');
              const specialLogEntryD = document.createElement('p');
              specialLogEntryD.textContent = specialLogMessage;
              specialLogEntryD.style.color = "#9966CC";  // Couleur pour la capacité spéciale
              combatLogDiva.appendChild(specialLogEntryD);

              handleAttack(character, opponent, isPlayer);
              break;

            case "Willy":
              character.spe -= 0.25;
              specialAbility -= 0.25;
              const opponentDefenseModifiee = 0.9 + Math.random() * 0.2; // Entre 0.9 et 1.1
              const opponentDefensee = Math.round(opponent.defense * opponentDefenseModifiee);
              opponent.pv += (2 * (opponentDefensee - character.attaque));
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il effectue 3 attaques !\n\n${character.name} attaque ${opponent.name} et inflige ${Math.round(2 * (character.attaque - opponentDefensee))} points de dégâts.`;
              character.degats_partie += (2 * (character.attaque - opponentDefensee));

              // Ajouter le message au journal
              const combatLogWilly = document.getElementById('combat-log');
              const specialLogEntryW = document.createElement('p');
              specialLogEntryW.textContent = specialLogMessage;
              specialLogEntryW.style.color = "#9966CC";  // Couleur pour la capacité spéciale
              combatLogWilly.appendChild(specialLogEntryW);

              handleAttack(character, opponent, isPlayer);


              character.last_action = 2;


              break;

            case "Baleine":
              if (character.defense < 29) {
                specialLogMessage = "Baleine n'a plus assez de défense pour utiliser sa capacité spéciale, il va donc attaquer.";

                // Ajouter le message au journal
                const combatLogBaleineFail = document.getElementById('combat-log');
                const specialLogEntryB = document.createElement('p');
                specialLogEntryB.textContent = specialLogMessage;
                specialLogEntryB.style.color = "#9966CC";  // Couleur pour la capacité spéciale
                combatLogBaleineFail.appendChild(specialLogEntryB);

                handleAttack(character, opponent, isPlayer);
              } else {
                specialLogMessage = "Baleine utilise sa capacité spéciale ! Il perd 15 de défense et gagne 1000 PV !";
                character.spe -= 0.25;
                if (isPlayer) {
                  specialAbility -= 0.25;
                }
                character.defense -= 15;
                character.pv += 1000;

                // Ajouter le message au journal
                const combatLogBaleine = document.getElementById('combat-log');
                const specialLogEntryB = document.createElement('p');
                specialLogEntryB.textContent = specialLogMessage;
                specialLogEntryB.style.color = "#9966CC";  // Couleur pour la capacité spéciale
                combatLogBaleine.appendChild(specialLogEntryB);

                handleAttack(character, opponent, isPlayer);
              }
              break;

            case "Doudou":
              character.spe -= 0.25;
              let regeneratedAmount;
              if (character.pv < (character.pv_max / 2)) {
                regeneratedAmount = Math.ceil(character.pv * 0.15);
                specialLogMessage = `${character.name} régénère ${Math.round(regeneratedAmount)} PV.`;
              } else {
                regeneratedAmount = Math.ceil(character.pv * 0.05);
                specialLogMessage = `${character.name} régénère ${Math.round(regeneratedAmount)} PV.`;
              }
              character.pv += regeneratedAmount;
              if (character.pv > character.pv_max) {
                character.pv = character.pv_max;
              }

              // Ajouter le message au journal
              const combatLogDoudou = document.getElementById('combat-log');
              const specialLogEntryDo = document.createElement('p');
              specialLogEntryDo.textContent = specialLogMessage;
              specialLogEntryDo.style.color = "#9966CC";  // Couleur pour la capacité spéciale
              combatLogDoudou.appendChild(specialLogEntryDo);

              handleAttack(character, opponent, isPlayer);
              break;

            case "Cocobi":
              const reductionAmount = Math.ceil(opponent.pv_maximum * 0.12);
              opponent.pv -= reductionAmount;
              if (opponent.pv < 0) {
                opponent.pv = 0;
              }
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! ${opponent.name} perd ${Math.round(reductionAmount)} PV.`;
              character.degats_partie += reductionAmount;

              // Ajouter le message au journal
              const combatLogCocobi = document.getElementById('combat-log');
              const specialLogEntryCo = document.createElement('p');
              specialLogEntryCo.textContent = specialLogMessage;
              specialLogEntryCo.style.color = "#9966CC";  // Couleur pour la capacité spéciale
              combatLogCocobi.appendChild(specialLogEntryCo);
              break;

            case "Coeur":
              const specialDamage = Math.round(character.attaque * 1.5);
              const absorbedHealth = Math.round(specialDamage * (character.pv > (character.pv_max / 2) ? 0.1 : 0.15));
              opponent.pv -= specialDamage;
              character.pv += absorbedHealth;
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(specialDamage)} points de dégâts et récupère ${Math.round(absorbedHealth)} PV.`;
              character.degats_partie += specialDamage;
              if (opponent.pv < 0) opponent.pv = 0;
              if (character.pv > character.pv_max) character.pv = character.pv_max;

              // Ajouter le message au journal
              const combatLogCoeur = document.getElementById('combat-log');
              const specialLogEntryCoe = document.createElement('p');
              specialLogEntryCoe.textContent = specialLogMessage;
              specialLogEntryCoe.style.color = "#9966CC";  // Couleur pour la capacité spéciale
              combatLogCoeur.appendChild(specialLogEntryCoe);
              break;

            case "Grours":
              const Damage = 500 + character.attaque;
              const defense = Math.round(opponent.defense * 0.5);
              opponent.pv -= (Damage - defense);
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(Damage - defense)} points de dégâts à ${opponent.name}, ignorant le bouclier.`;
              character.degats_partie += (Damage - defense);

              // Ajouter le message au journal
              const combatLogGrours = document.getElementById('combat-log');
              const specialLogEntryG = document.createElement('p');
              specialLogEntryG.textContent = specialLogMessage;
              specialLogEntryG.style.color = "#9966CC";  // Couleur pour la capacité spéciale
              combatLogGrours.appendChild(specialLogEntryG);
              break;

            case "Poulpy":
              const poulpyDamage = Math.round(character.attaque * 1.75);
              const effectiveDefense = Math.round(opponent.defense * 0.6);
              const netDamage = Math.max(0, poulpyDamage - effectiveDefense);
              opponent.pv -= netDamage;
              opponent.defense *= 0.85;
              opponent.poulpy_att += 3;
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(netDamage)} points de dégâts à ${opponent.name}, ignore 50% de sa défense et réduit sa défense de 15% pour les 2 prochains tours.`;
              character.degats_partie += netDamage;

              // Ajouter le message au journal
              const combatLogPoulpy = document.getElementById('combat-log');
              const specialLogEntryP = document.createElement('p');
              specialLogEntryP.textContent = specialLogMessage;
              specialLogEntryP.style.color = "#9966CC";  // Couleur pour la capacité spéciale
              combatLogPoulpy.appendChild(specialLogEntryP);
              break;

            case "Oiseau":
              const DamageOiseau = character.attaque * 2.5;
              character.defense += 20;
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(DamageOiseau)} points de dégâts et gagne 20 de défense.`;
              opponent.pv -= DamageOiseau;
              character.Oiseaudefense += 2;
              character.degats_partie += DamageOiseau;

              // Ajouter le message au journal
              const combatLogOiseau = document.getElementById('combat-log');
              const specialLogEntryO = document.createElement('p');
              specialLogEntryO.textContent = specialLogMessage;
              specialLogEntryO.style.color = "#9966CC";  // Couleur pour la capacité spéciale
              combatLogOiseau.appendChild(specialLogEntryO);
              break;

            case "Colorina":
              const colorinaDamage = Math.round(character.attaque * 0.85);
              opponent.pv -= colorinaDamage;
              opponent.defense *= 0.85;
              opponent.perte_defense_colorina += 4;
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(colorinaDamage)} points de dégâts et réduit la défense de ${opponent.name} de 15% pour les 3 prochains tours.`;
              character.degats_partie += colorinaDamage;

              // Ajouter le message au journal
              const combatLogColorina = document.getElementById('combat-log');
              const specialLogEntryCol = document.createElement('p');
              specialLogEntryCol.textContent = specialLogMessage;
              specialLogEntryCol.style.color = "#9966CC";  // Couleur pour la capacité spéciale
              combatLogColorina.appendChild(specialLogEntryCol);
              break;
            case "Rosalie":
              const rosalieDamage = Math.round(character.attaque * 2);
              const immobilizationChance = Math.random();
              if (immobilizationChance < 0.25) {
                opponent.immobilisation = 1; // Marque l'adversaire comme immobilisé
                specialLogMessage = `${character.name} utilise sa capacité spéciale ! Elle inflige ${Math.round(rosalieDamage)} points de dégâts et immobilise ${opponent.name} pour un tour.`;
              } else {
                specialLogMessage = `${character.name} utilise sa capacité spéciale ! Elle inflige ${Math.round(rosalieDamage)} points de dégâts.`;
              }
              opponent.pv -= rosalieDamage;
              if (opponent.pv < 0) opponent.pv = 0;
              character.degats_partie += rosalieDamage;
              const combatLogRosalie = document.getElementById('combat-log');
              const specialLogEntryR = document.createElement('p');
              specialLogEntryR.textContent = specialLogMessage;
              specialLogEntryR.style.color = "#9966CC";  // Couleur pour la capacité spéciale
              combatLogRosalie.appendChild(specialLogEntryR);

              break;
            case "Sboonie":
              pvsupp = Math.round(character.pv_max * 0.08)
              character.pv += pvsupp;
              opponent.pv -= 50;
              opponent.attaque = Math.round(opponent.attaque * 0.85);
              if (!isPlayer) {
                opponent.sboonie_attaque += 1;
              }
              opponent.sboonie_attaque += 1;
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il régénère ${Math.round(pvsupp)} PV, inflige 50 de dégâts et reduit de 15% l'attaque de ${opponent.name} pour le prochain tour.`;
              const combatLogSboonie = document.getElementById('combat-log');
              const specialLogEntryS = document.createElement('p');
              specialLogEntryS.textContent = specialLogMessage;
              specialLogEntryS.style.color = "#9966CC";  // Couleur pour la capacité spéciale
              combatLogSboonie.appendChild(specialLogEntryS);

              break;

            case 'Inconnu':
              opponent.inconnu_super += 3;
              if (isPlayer) {
                opponent.inconnu_super += 1;
              }
              character.attaque += 25;
              character.defense += 25;
              specialLogMessage = `${character.name} utilise sa capacité spécial, il augmente son attaque et sa défense de 15 et ${opponent.name} ne peut pas utiliser sa capacité spéciale pendant 3 tours !`;
              const combatLogInconnu = document.getElementById('combat-log');
              const specialLogEntryI = document.createElement('p');
              specialLogEntryI.textContent = specialLogMessage;
              specialLogEntryI.style.color = "#9966CC";  // Couleur pour la capacité spéciale
              combatLogInconnu.appendChild(specialLogEntryI);
              handleAttack(character, opponent, isPlayer);
              break;

            default:
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Effet spécifique à définir.`;

              // Ajouter le message au journal
              const combatLogDefault = document.getElementById('combat-log');
              const specialLogEntry = document.createElement('p');
              specialLogEntry.textContent = specialLogMessage;
              specialLogEntry.style.color = "#9966CC";  // Couleur pour la capacité spéciale
              combatLogDefault.appendChild(specialLogEntry);
          }
        }

        // Met à jour l'affichage des PV du joueur ou de l'adversaire
        document.getElementById(isPlayer ? 'player-pv' : 'opponent-pv').textContent = `PV: ${character.pv}`;

        // Met à jour le bouton après l'utilisation si c'est le joueur

        character.last_action = 2;
        updateSpecialButton();
        updateSpecialBar(playerCharacter, 'player-special-bar');
        updateSpecialBar(opponentCharacter, 'opponent-special-bar');
        updateUI();

        scrollToBottom();
        if (isPlayer && character.name != "Diva" && character.name != "Willy" && character.name != "Baleine" && character.name != "Doudou") {
          opponentTurn();
        }
      }
    }





    function opponentTurn() {
      // Exécuter le tour de l'IA

      // État actuel du joueur
      let Jdefense = playerCharacter.defense_droit;
      if (playerCharacter.defense_droit > 0 && playerCharacter.defense_droit < 1) {
        Jdefense = 0;
      } else if (playerCharacter.defense_droit >= 1) {
        Jdefense = 1;
      }
      let Jcs = playerCharacter.spe; // Capacité spéciale (binaire)
      if (playerCharacter.spe > 0 && playerCharacter.spe < 1) {
        Jcs = 0;
      } else if (playerCharacter.spe >= 1) {
        Jcs = 1;
      }
      let Jpv = Math.min(Math.ceil((playerCharacter.pv / playerCharacter.pv_max) * 100 / 20) * 20, 100); // Vie en % par palier de 20
      let Jaction = playerCharacter.last_action; // Dernière action du joueur
      console.log(Jaction);

      // État actuel de l'IA
      let IAdefense = opponentCharacter.defense_droit; // Défense droit (binaire)
      if (opponentCharacter.defense_droit > 0 && opponentCharacter.defense_droit < 1) {
        IAdefense = 0;
      }
      let IAcs = opponentCharacter.spe; // Capacité spéciale (binaire)
      if (opponentCharacter.spe > 0 && opponentCharacter.spe < 1) {
        IAcs = 0;
      } else if (opponentCharacter.spe >= 1) {
        IAcs = 1;
      }
      let IApv = Math.min(Math.ceil((opponentCharacter.pv / opponentCharacter.pv_max) * 100 / 20) * 20, 100); // Vie en % par palier de 20

      iaTurn(opponentCharacter, playerCharacter);

      // État actuel global
      const currentState = [Jcs, Jdefense, Jpv, Jaction, IAcs, IAdefense, IApv];
      console.log("Current state:", currentState);

      // Trouver les données similaires
      const similarData = findSimilarData(currentState, historicalData);

      // Prédire l'action probable du joueur
      const predictedAction = mostProbableAction(similarData);
      console.log("Predicted action:", predictedAction);
      opponentCharacter.next_choice = predictedAction;

      // Ajouter le tour actuel aux données historiques
      historicalData.push(currentState);

      // Sauvegarder les données
      saveHistoricalData(historicalData);

      // Attendre que l'IA ait fini son tour avant de passer au tour suivant
      setTimeout(() => {
        adversairepasser_tour();
        joueurpasser_tour();
        updateSpecialBar(playerCharacter, 'player-special-bar');
        updateSpecialBar(opponentCharacter, 'opponent-special-bar');
        updateUI();
      }, 1000); // Attente de 1 seconde (ajuste si nécessaire)
    }

    // Charger ou initialiser les données historiques
    const savedData = localStorage.getItem("historicalData");
    const historicalData = savedData ? JSON.parse(savedData) : [];

    // Trouver les données similaires dans les données historiques
    function findSimilarData(currentState, data) {
      console.log("Searching for similar data...");
      const stateToMatch = [...currentState.slice(0, 3), ...currentState.slice(4)]; // État sans l'action actuelle

      const similarData = data.filter((row) => {
        const rowState = [...row.slice(0, 3), ...row.slice(4)];
        return JSON.stringify(rowState) === JSON.stringify(stateToMatch);
      });

      console.log("Similar data found:", similarData);
      return similarData;
    }

    // Trouver l'action la plus probable
    // Trouver l'action la plus probable
    function mostProbableAction(data) {
      console.log("Choosing the most probable action...");
      if (data.length === 0) return null; // Aucun historique trouvé

      // Extraire les actions des données similaires
      const actions = data.map((row) => row[3]);

      // Compter les occurrences des actions
      const actionCounts = actions.reduce((counts, action) => {
        counts[action] = (counts[action] || 0) + 1;
        return counts;
      }, {});

      console.log("Action counts:", actionCounts);

      // Trouver l'action la plus fréquente
      const mostFrequentAction = Object.keys(actionCounts).reduce((a, b) =>
        actionCounts[a] > actionCounts[b] ? a : b
      );

      return mostFrequentAction;
    }

    // Tour de l'IA
    function iaTurn(IA, playerCharacter) {
      console.log("IA is thinking...");

      let choice = opponentCharacter.next_choice;

      // Vérifier si l'action prédite est valide
      if (choice === null) {
        console.log("Aucune action prédite !");
        handleAttack(opponentCharacter, playerCharacter, false);
      }
      console.log("Predicted action:", choice);
      console.log("test", opponentCharacter.spe)

      // Fonction pour choisir une action aléatoire parmi les options
      function getRandomAction(actions) {
        return actions[Math.floor(Math.random() * actions.length)];
      }

      // Cas où opponentCharacter.spe = 1 et opponentCharacter.defense_droit = 0
      if (IA.spe === 1 && IA.defense_droit === 0) {
        console.log("c'est bon ???")
        if (choice === "0") {
          const action = getRandomAction(["attacker", "utiliser capacité spéciale"]);
          if (action === "attacker") {
            console.log("IA choisit d'attaquer.");
            handleAttack(opponentCharacter, playerCharacter, false);
          } else {
            console.log("IA utilise sa capacité spéciale.");
            useSpecialAbility(opponentCharacter, playerCharacter, false);;
          }
        } else if (choice === "1") {
          console.log("IA attaque.");
          handleAttack(opponentCharacter, playerCharacter, false);
        } else if (choice === "2") {
          console.log("IA utilise sa capacité spéciale.");
          useSpecialAbility(opponentCharacter, playerCharacter, false);
        }
      }

      // Cas où opponentCharacter.spe = 1 et opponentCharacter.defense_droit = 1
      else if (IA.spe === 1 && IA.defense_droit === 1) {
        console.log("c'est bon ???")
        if (choice === "0") {
          const action = getRandomAction(["attacker", "utiliser capacité spéciale"]);
          if (action === "attacker") {
            console.log("IA choisit d'attaquer.");
            handleAttack(opponentCharacter, playerCharacter, false);
          } else {
            console.log("IA utilise sa capacité spéciale.");
            useSpecialAbility(opponentCharacter, playerCharacter, false);
          }
        } else if (choice === "1") {
          console.log("IA attaque.");
          handleAttack(opponentCharacter, playerCharacter, false);
        } else if (choice === "2") {
          console.log("IA utilise sa capacité spéciale ou attaque.");
          const action = getRandomAction(["utiliser capacité spéciale", "attacker"]);
          if (action === "utiliser capacité spéciale") {
            useSpecialAbility(opponentCharacter, playerCharacter, false);
          } else {
            handleAttack(opponentCharacter, playerCharacter, false);
          }
        }
      }

      // Cas où opponentCharacter.spe = 0 et opponentCharacter.defense_droit = 0
      else if (IA.spe != 0 && IA.defense_droit === 0) {
        console.log("c'est bon putain???")
        if (choice === "1" || choice === "0") {
          console.log("IA choisit d'attaquer.");
          handleAttack(opponentCharacter, playerCharacter, false);
        } else if (choice === "2") {
          console.log("IA se défend.");
          opponentDefense();
        }
      }

      // Cas où opponentCharacter.spe = 0 et opponentCharacter.defense_droit = 1
      else if (IA.spe != 1 && IA.defense_droit === 0) {
        console.log("c'est bon ???")
        console.log("IA attaque.");
        handleAttack(IA, playerCharacter, false);
      }

      console.log("IA's turn is over.");
    }

    // Sauvegarder les données historiques
    function saveHistoricalData(data) {
      localStorage.setItem("historicalData", JSON.stringify(data));
    }

    // Charger les données depuis localStorage
    function loadHistoricalData() {
      const data = localStorage.getItem("historicalData");
      return data ? JSON.parse(data) : [];
    }


    function opponentDefense() {
      opponentCharacter.defense_bouton = 1;
      opponentCharacter.defense_droit = 4;
      const combatLog = document.getElementById('combat-log');
      const logEntry = document.createElement('p');
      const soin = Math.round(opponentCharacter.degats_subit * 0.8)
      opponentCharacter.pv += soin;
      logEntry.textContent = `${opponentCharacter.name} se defend de la dernière attaque de ${playerCharacter.name}.`;
      logEntry.style.color = '#6699CC';
      combatLog.appendChild(logEntry);
      scrollToBottom();
      handleAttack(opponentCharacter, playerCharacter, false)

    }

    function handleDefense(character, opponent, isPlayer) {


      const combatLog = document.getElementById('combat-log');
      const logEntry = document.createElement('p');
      if (character.defense_droit === 0) {
        if (character.spe >= 0.1) {
          character.spe -= 0.1;
          character.defense_bouton = 1;
          character.defense_droit = 4;
          logEntry.textContent = `${character.name} se defend contre la prochaine attaque de ${opponent.name}.`;
          logEntry.style.color = '#6699CC';
          combatLog.appendChild(logEntry);
          if (isPlayer) {
            character.last_action = 1;
            character.defense_partie += 1;
            opponentTurn();
          }
        } else {
          logEntry.textContent = `${character.name} n'a pas assez d'énergie spéciale pour se défendre !`;
          logEntry.style.color = '#6699CC';
          combatLog.appendChild(logEntry);
          handleAttack(character, opponent, true)
        }

      } else if (isPlayer) {
        logEntry.textContent = `${character.name} ne peut pas se défendre avant dans ${character.defense_droit} tours.`;
        logEntry.style.color = '#6699CC';
        combatLog.appendChild(logEntry);
        handleAttack(character, opponent, true)
      } else if (!isPlayer) {
        logEntry.textContent = `${character.name} ne peut pas se défendre avant dans ${character.defense_droit} tours.`;
        logEntry.style.color = '#6699CC';
      }
      updateSpecialBar(playerCharacter, 'player-special-bar');
      updateSpecialBar(opponentCharacter, 'opponent-special-bar');
      updateUI();
    }

    function handleAttack(attacker, defender, isPlayerAttacking) {
      // Augmenter spe de 0.25 à chaque attaque
      if (isPlayerAttacking) {
        specialAbility = attacker.spe;
        attacker.last_action = 0;
      }

      if (isPlayerAttacking && attacker.spe < 0) {
        attacker.last_action = 2;
      }


      if (attacker.name === "Doudou" || attacker.name === "Diva" || attacker.name === "Cocobi") {
        attacker.spe += 0.20;
      } else {
        attacker.spe += 0.25;
      }


      if (attacker.spe >= 1) {
        attacker.spe = 1;
      }
      const combatLog = document.getElementById('combat-log');
      const logEntry = document.createElement('p');
      logEntry.style.color = '#CC3333';  // Couleur rouge brique pour l'attaque


      let damage;
      if (isPlayerAttacking) {

      }

      if (attacker.immobilisation > 0) {
        damage = 0;
        logEntry.textContent = `${defender.name} à immobilisé ${attacker.name} ! il ne peut donc pas attaquer.`;
        combatLog.appendChild(logEntry);
      } else if (defender.cape) {
        damage = 0;
        logEntry.textContent = `${defender.name} à utilisé une cape de l'ombre, ${attacker.name} ne l'as donc pas atteint !`;
        combatLog.appendChild(logEntry);
      } else {

        // Calculer une défense aléatoire entre 85% et 115% de la défense originale de l'adversaire
        const defenseModifier = 0.9 + Math.random() * 0.2; // Entre 0.9 et 1.1
        const modifiedDefense = Math.round(defender.defense * defenseModifier);
        damage = Math.max(0, attacker.attaque - modifiedDefense);

        if (defender.defense_bouton === 1) {
          defender.defense_bouton = 0;
          damage = Math.round(attacker.attaque * 0.2); // Infliger 0 dégâts si la défense est activée
        }


        // Mettre à jour les PV du défenseur
        opponentCharacter.degats_subit = damage;
        let currentPV = defender.pv - damage;
        if (currentPV < 0) {
          currentPV = 0;
        }
        defender.pv = currentPV;

        if (isPlayerAttacking) {
          logEntry.textContent = `Vous attaquez et infligez ${damage} points de dégâts à ${defender.name}.`;
          document.getElementById('opponent-pv').textContent = `PV: ${currentPV}`;
        } else {
          logEntry.textContent = `${attacker.name} attaque et inflige ${damage} points de dégâts.`;
          document.getElementById('player-pv').textContent = `PV: ${currentPV}`;
        }
        combatLog.appendChild(logEntry);

        if (isPlayerAttacking) {
          playerCharacter.degats_partie += damage;
          if (playerCharacter.spe >= 0.1) {
            playerCharacter.degats_partie_base += damage;
          }
        }
      }

      // Vérifier si le défenseur est vaincu
      if (defender.pv === 0) {
        const userData = getUserData();
        let perteTrophees = 0;

        if (isPlayerAttacking) {
          userData.victoires += 1;
          userData.trophees += 10;
          userData.fin_trophee = 10;
          if (userData.parties_test < 5) {
            userData.trophees -= 10;
          }

        } else {

          userData.defaites += 1;
          if (userData.trophees < 150) {
            perteTrophees = 1
          } else if (userData.trophees <= 150) {
            perteTrophees = 3;
          } else if (userData.trophees <= 300) {
            perteTrophees = 5;
          } else if (userData.trophees <= 500) {
            perteTrophees = 8;
          } else if (userData.trophees <= 750) {
            perteTrophees = 10;
          } else {
            perteTrophees = 12;
          }

          if (userData.parties_test < 5) {
            perteTrophees = 0;
          }

          userData.trophees -= perteTrophees;
          if (userData.trophees < 0) {
            userData.trophees = 0;
          }
          saveUserData(userData);
        }

        let gain_XP = calculateXP(attacker, defender, isPlayerAttacking);
        let gain_argent = Math.round(gain_XP / 3);
        if (gain_XP < 20 && isPlayerAttacking) {
          gain_XP = 20;
        }
        if (userData.XP_jour >= 2500) {
          gain_XP = 0;
        }
        userData.XP_jour += gain_XP;

        saveUserData(userData);

        if (userData.Double_XP > 0) {
          gain_XP *= 2;
          userData.Double_XP -= 1;
        } else if (userData.Double_XP_acheté > 0) {
          userData.Double_XP_acheté -= 1;
          gain_XP *= 2;
        }
        if (userData.parties_test < 5) {
          gain_argent = 0;
          gain_XP = 0;
          userData.parties_test += 1;
          saveUserData(userData);
        }
        userData.pass_XP += gain_XP;
        saveUserData(userData);

        updateCharacterXP(userData, playerCharacter.name, gain_XP);
        userData.argent += gain_argent;

        if (isPlayerAttacking) {
          combatLog.innerHTML += `<p>${defender.name} a été vaincu !`;
          userData.gagnant = attacker.name;
          userData.fin_xp = gain_XP;
          userData.fin_argent = gain_argent;
          saveUserData(userData);
        } else {
          combatLog.innerHTML += `<p>${attacker.name} vous a vaincu !`;
          userData.gagnant = attacker.name;
          userData.fin_xp = gain_XP;
          userData.fin_argent = gain_argent;
          userData.fin_trophee = -perteTrophees;
          saveUserData(userData);
        }
        saveUserData(userData);

        document.getElementById('attack-button').disabled = true;
        document.getElementById('special-button').disabled = true;

        for (let week = 1; week <= 5; week++) {
          if (userData[`semaine${week}`]) {
            for (let quest = 1; quest <= 5; quest++) {
              const questKey = `Semaine${week}_${quest}`;
              const questCompletedKey = `${questKey}_completed`;
              const questTypeKey = `${questKey}_type`;
              const questCurrentKey = `${questKey}_current`;
              const questCharacter = `${questKey}_character`;

              if (!userData[questCompletedKey]) {
                switch (userData[questTypeKey]) {
                  case 'VCS':
                    if (isPlayerAttacking) {
                      userData[questCurrentKey] += 1;
                      saveUserData(userData);
                    }
                  case 'CC':
                    userData[questCurrentKey] += playerCharacter.capacite_partie;
                    saveUserData(userData);
                    break;
                  case 'VPCS':
                    if (isPlayerAttacking && playerCharacter.name === userData[questCharacter]) {
                      userData[questCurrentKey] += 1;
                      saveUserData(userData);
                    }
                    break;
                  case 'DSC':
                    userData[questCurrentKey] += playerCharacter.degats_partie;
                    saveUserData(userData);
                    break;
                  case 'O':
                    userData[questCurrentKey] += playerCharacter.objets_partie;
                    saveUserData(userData);
                    break;
                  case 'DC':
                    userData[questCurrentKey] += playerCharacter.defense_partie;
                    saveUserData(userData);
                    break;
                }
                saveUserData(userData);
              }
            }
          }
        }

        if (userData.quete1_type === "victoire_classique" && playerCharacter.name === userData.quete1_character && isPlayerAttacking) {
          userData.quete1_current += 1;
          saveUserData(userData);
        } else if (userData.quete1_type === "dommages_classique") {
          userData.quete1_current += playerCharacter.degats_partie;
          saveUserData(userData);
        } else if (userData.quete1_type === "objets_total") {
          userData.quete1_current += playerCharacter.objets_partie;
          saveUserData(userData);
        } else if (userData.quete1_type === "defense_classique") {
          userData.quete1_current += playerCharacter.defense_partie;
          saveUserData(userData);
        }

        if (userData.quete2_type === "victoire_classique" && playerCharacter.name === userData.quete2_character && isPlayerAttacking) {
          userData.quete2_current += 1;
          saveUserData(userData);
        } else if (userData.quete2_type === "dommages_classique") {
          userData.quete2_current += playerCharacter.degats_partie;
          saveUserData(userData);
        } else if (userData.quete2_type === "objets_total") {
          userData.quete2_current += playerCharacter.objets_partie;
          saveUserData(userData);
        } else if (userData.quete2_type === "defense_classique") {
          userData.quete2_current += playerCharacter.defense_partie;
          saveUserData(userData);
        }

        if (userData.quete3_type === "victoire_classique" && playerCharacter.name === userData.quete3_character && isPlayerAttacking) {
          userData.quete3_current += 1;
          saveUserData(userData);
        } else if (userData.quete3_type === "dommages_classique") {
          userData.quete3_current += playerCharacter.degats_partie;
          saveUserData(userData);
        } else if (userData.quete3_type === "objets_total") {
          userData.quete3_current += playerCharacter.objets_partie;
          saveUserData(userData);
        } else if (userData.quete3_type === "defense_classique") {
          userData.quete3_current += playerCharacter.defense_partie;
          saveUserData(userData);
        }

        updateCharacterXP(userData, playerCharacter.name, gain_XP);
        userData.argent += gain_argent;

        // Enregistrer le gagnant et les récompenses dans sessionStorage
        checkAndDisplayCharacterUnlock(userData);
        saveUserData(userData);
        setTimeout(() => {
          localStorage.removeItem("savepartie");
          sessionStorage.removeItem('playerCharacter');
          sessionStorage.removeItem('opponentCharacter');
          window.location.href = 'fin_partie.html';
        }, 2000);
      } else if (isPlayerAttacking) {
        // Tour de l'adversaire si le joueur attaque et n'a pas encore vaincu l'adversaire
        opponentTurn();
        updateSpecialBar(playerCharacter, 'player-special-bar');
        updateSpecialBar(opponentCharacter, 'opponent-special-bar');
        updateUI();
      }

      updateSpecialButton();
      scrollToBottom();
    }

    function calculateXP(attacker, defender, isPlayerAttacking) {
      let userData = getUserData();
      let niveau = Number(userData[attacker.name + "_Level"]) * 0.1;
      if (isPlayerAttacking) {
        let joueur_pv = attacker.pv;
        let joueur_pv_base = attacker.pv_max;
        return Math.round((2 * (joueur_pv / joueur_pv_base) * 100) * (1 / (1 + niveau)));
      } else if (userData.XP_jour >= 2500) {
        return 0;
      } else {
        return Math.round(20 - (2 * (niveau - 1)));
      }
    }

    function updateCharacterXP(userData, characterName, xp) {

      switch (characterName) {
        case "Willy":
          userData.Willy_XP += xp;
          break;
        case "Cocobi":
          userData.Cocobi_XP += xp;

          break;
        case "Oiseau":
          userData.Oiseau_XP += xp;

          break;
        case "Grours":
          userData.Grours_XP += xp;

          break;
        case "Baleine":
          userData.Baleine_XP += xp;

          break;
        case "Doudou":
          userData.Doudou_XP += xp;

          break;
        case "Coeur":
          userData.Coeur_XP += xp;

          break;
        case "Diva":
          userData.Diva_XP += xp;

          break;
        case "Poulpy":
          userData.Poulpy_XP += xp;

          break;
        case "Colorina":
          userData.Colorina_XP += xp;

          break;
          saveUserData(userData);
      }
    }

    function scrollToBottom() {
      const combatLog = document.getElementById('combat-log');
      combatLog.scrollTop = combatLog.scrollHeight;
    }
    // Fonction pour vérifier et afficher le déblocage d'un nouveau personnage
    function checkAndDisplayCharacterUnlock(userData) {
      // Définition des paliers de récompense avec des écarts de plus en plus grands
      const rewardPals = [
        {trophies: 10},
        {trophies: 20},
        {trophies: 30},
        {trophies: 40},
        {trophies: 60},
        {trophies: 80},
        {trophies: 100},
        {trophies: 120},
        {trophies: 150},
        {trophies: 180},
        {trophies: 220},
        {trophies: 260},
        {trophies: 300},
        {trophies: 350},
        {trophies: 400},
        {trophies: 460},
        {trophies: 520},
        {trophies: 580},
        {trophies: 650},
        {trophies: 720},
        {trophies: 800},
        {trophies: 880},
        {trophies: 970},
        {trophies: 1060},
        {trophies: 1150},
        {trophies: 1250},
        {trophies: 1350},
        {trophies: 1460},
        {trophies: 1570},
        {trophies: 1690}
      ];

      // Initialiser les paliers de récompense si non défini
      if (!userData.palier_recompense) {
        userData.palier_recompense = [];
      }

      let newPalsReached = 0;

      for (const reward of rewardPals) {
        if (userData.trophees >= reward.trophies) {
          if (!userData.palier_recompense.includes(reward.trophies)) {
            userData.palier_recompense.push(reward.trophies);
            userData.recompense += 1;
            newPalsReached++;
          }
        }
      }

      // Ajouter un personnage récompense tous les 8 nouveaux paliers atteints
      if (newPalsReached > 0 && (userData.palier_recompense.length % 10 === 0)) {
        userData.perso_recompense = (userData.perso_recompense || 0) + 1;
      }

      saveUserData(userData);
    }

    function sauvegarderPartie(playerCharacter, opponentCharacter) {
      const sauvegarde = {
        playerCharacter: {
          name: playerCharacter.name,
          pv: playerCharacter.pv,
          pv_max: playerCharacter.pv_max,
          attaque: playerCharacter.attaque,
          defense: playerCharacter.defense,
          spe: playerCharacter.spe,
          attaque_originale: playerCharacter.attaque_originale,
          defense_originale: playerCharacter.defense_originale,
          perte_att: playerCharacter.perte_att,
          Oiseaudefense: playerCharacter.Oiseaudefense,
          perte_defense_colorina: playerCharacter.perte_defense_colorina,
          amulette_soin: playerCharacter.amulette_soin,
          attaque_epee: playerCharacter.attaque_epee,
          attaque_elixir: playerCharacter.attaque_elixir,
          armure: playerCharacter.armure,
          degats_partie: playerCharacter.degats_partie,
          objets_partie: playerCharacter.objets_partie,
          capacite_partie: playerCharacter.capacite_partie,
          degats_partie_base: playerCharacter.degats_partie_base,
          objets_soin: playerCharacter.objets_soin,
          defense_bouton: playerCharacter.defense_bouton,
          defense_droit: playerCharacter.defense_droit,
          defense_solide: playerCharacter.defense_solide,
          defense_partie: playerCharacter.defense_partie,
          immobilisation: playerCharacter.immobilisation || 0,
          sboonie_attaque: playerCharacter.sboonie_attaque || 0,
          poulpy_att: playerCharacter.poulpy_att || 0,
          objets_utilise: playerCharacter.objets_utilise || 0,
          inventaire_objets: playerCharacter.inventaire_objets || false,
          amuletteUses: playerCharacter.amuletteUses || 0,
          armureUses: playerCharacter.armureUses || 0,
          tour: playerCharacter.tour || 1,
          cape: playerCharacter.cape || false,
          capeUses: playerCharacter.capeUses || 0,
          crystalUses: playerCharacter.crystalUses || 0,
          inconnu_super: playerCharacter.inconnu_super || 0,
          last_action: playerCharacter.last_action || 0
        },
        opponentCharacter: {
          name: opponentCharacter.name,
          pv: opponentCharacter.pv,
          pv_max: opponentCharacter.pv_max,
          attaque: opponentCharacter.attaque,
          defense: opponentCharacter.defense,
          spe: opponentCharacter.spe,
          attaque_originale: opponentCharacter.attaque_originale,
          defense_originale: opponentCharacter.defense_originale,
          perte_att: opponentCharacter.perte_att || 0,
          Oiseaudefense: opponentCharacter.Oiseaudefense || 0,
          perte_defense_colorina: opponentCharacter.perte_defense_colorina || 0,
          pv_maximum: opponentCharacter.pv,
          immobilisation: opponentCharacter.immobilisation || 0,
          defense_bouton: opponentCharacter.defense_bouton || 0,
          defense_droit: opponentCharacter.defense_droit || 0,
          sboonie_attaque: opponentCharacter.sboonie_attaque || 0,
          poulpy_att: opponentCharacter.poulpy_att || 0,
          degats_subit: opponentCharacter.degats_subit || 0,
          inconnu_super: opponentCharacter.inconnu_super || 0,
          next_choice: opponentCharacter.next_choice || "0"
        }
      };

      localStorage.setItem("savepartie", JSON.stringify(sauvegarde));
    }

    


    
    userData.partie_commencee = true;
    saveUserData(userData);

  </script>
</body>

</html>