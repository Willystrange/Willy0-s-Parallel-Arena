<!DOCTYPE html>
<html lang="fr">

<head>
  <link rel="icon" type="image/png" href="icon.png">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <title>Willy0's Parallel Arena</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: no-repeat center center fixed;
      background-size: cover;
      color: #333;
      transition: background-color 0.3s, color 0.3s;
      position: relative;
      overflow: hidden;
      /* Empêche le défilement du body */
    }

    html {
      touch-action: manipulation;
    }


    .content {
      overflow-y: auto;
      /* Permet le défilement vertical */
      height: 100vh;
      /* Occupe toute la hauteur de la fenêtre */
      -webkit-overflow-scrolling: touch;
      /* Assure le défilement fluide sur les appareils tactiles */
    }

    .top-bar {
      height: 100px;
      background-color: #d1d1d6;
      display: flex;
      align-items: center;
      padding: 10px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      justify-content: space-between;
    }

    .header-info {
      display: flex;
      flex-direction: column;
      margin: 0 20px;
    }

    .header-info h3,
    .header-info p {
      margin: 0;
      padding: 0;
    }

    #player-money {
      display: none;
    }

    .combat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 20px;
      padding-bottom: 20px;
      box-sizing: border-box;
      margin: 100;
    }

    #combat-log {
      position: absolute;
      top: calc(100px + 20px);
      /* Hauteur de .top-bar (100px) + 20px d'écart */
      bottom: calc(60px + 20px);
      /* Hauteur de .combat-actions-wrapper (60px) + 20px d'écart */
      left: 0;
      right: 0;
      overflow-y: auto;
      background-color: #f0f0f0;
      padding: 10px;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }






    .combat-actions-wrapper {
      position: fixed;
      bottom: 0px;
      width: 100%;
      background-color: #fff;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
      padding-top: 10px;
    }

    body.web-app .combat-actions-wrapper {
      bottom: 0px;
    }

    .combat-actions {
      display: flex;
      justify-content: space-around;
    }

    .combat-actions button {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      padding: 0;
      font-size: 0;
      line-height: 0;
      background-color: transparent;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.3s;
    }

    .combat-actions button#defense-button {
      background-image: url('defense.png');
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
    }

    .combat-actions button#attack-button {
      background-image: url('attaque.png');
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
    }

    .combat-actions button#special-button {
      background-image: url('special.png');
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
    }

    .combat-actions button#special-button.bright {
      filter: brightness(1.5) drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));
    }

    .combat-actions button#special-button.grow {
      transform: scale(1.1);
    }

    .combat-actions button#items-button {
      background-image: url('inventaire.png');
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
    }

    #item-selection {
      display: none;
      text-align: center;
      margin-top: 10px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      max-height: 300px;
      overflow-y: auto;
    }

    #item-selection button {
      display: block;
      width: 100%;
      max-width: 200px;
      padding: 15px;
      margin: 10px auto;
      font-size: 18px;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background-color: #4CAF50;
      color: white;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      transition: background-color 0.3s, transform 0.3s;
    }

    #item-selection button:hover {
      background-color: #45a049;
      transform: scale(1.05);
    }

    #item-selection button:active {
      background-color: #388e3c;
      transform: scale(1.02);
    }

    /* Styles pour le mode sombre */
    @media (prefers-color-scheme: dark) {
      body {
        background-color: #000;
        color: #e0e0e0;
      }

      .top-bar {
        background-color: #333;
      }

      .combat-actions-wrapper {
        background-color: #333;
      }

      .combat-actions button {
        background-color: #333;
        color: #e0e0e0;
      }

      .combat-actions button:hover {
        background-color: #333;
      }

      #combat-log {
        background-color: #333;
        border-color: #444;
        color: #e0e0e0;
      }

      #item-selection {
        background-color: #333;
        color: #e0e0e0;
        border-color: #444;
      }

      #item-selection button {
        background-color: #444;
        color: #e0e0e0;
        border-color: #555;
      }

      #item-selection button:hover {
        background-color: #555;
      }
    }

    .special-bar {
      width: 100%;
      background-color: #ddd;
      border-radius: 5px;
      height: 5px;
      overflow: hidden;
      margin: 5px 0;
    }

    .special-fill {
      height: 100%;
      width: 0;
      background-color: #4CAF50;
      transition: width 0.3s ease-in-out;
    }

    /* Masquer les barres de défilement */
    .content::-webkit-scrollbar {
      display: none;
    }

    .content {
      scrollbar-width: none;
    }

    .content {
      -ms-overflow-style: none;
    }

    html,
    body {
      position: fixed;
      overflow: hidden;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    * {
      max-width: 100%;
      box-sizing: border-box;
    }

    @media screen and (orientation: landscape) and (max-width: 1024px) {
      body::before {
        content: "Veuillez tourner votre appareil en mode portrait.";
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        font-size: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        z-index: 9999;
      }
    }
  </style>
  <style>
    @media (min-width: 4px) {
      .combat-actions-wrapper {
        position: absolute;
        bottom: 0;
      }
    }
  </style>
</head>

<body>
  <div class="content">
    <div class="top-bar">
      <div class="header-info">
        <h3 id="player-name"></h3>
        <p id="player-pv"></p>
        <div id="player-special-bar" class="special-bar">
          <div id="player-special-fill" class="special-fill"></div>
        </div>
        <p id="player-attack"></p>
        <p id="player-defense"></p>
      </div>
      <div class="header-info">
        <h3 id="opponent-name"></h3>
        <p id="opponent-pv"></p>
        <div id="opponent-special-bar" class="special-bar">
          <div id="opponent-special-fill" class="special-fill"></div>
        </div>
        <p id="opponent-attack"></p>
        <p id="opponent-defense"></p>
      </div>
    </div>

    <div class="combat-container">
      <div id="combat-log"></div>
    </div>

    <div class="combat-actions-wrapper">
      <div class="combat-actions">
        <button id="attack-button"
          onclick="updateTour(), handleAttack(playerCharacter, opponentCharacter, true);"></button>
        <button id="defense-button"
          onclick="updateTour(), handleDefense(playerCharacter, opponentCharacter, true);"></button>
        <button id="special-button"
          onclick="updateTour(), useSpecialAbility(playerCharacter, opponentCharacter, true);"></button>
        <button id="items-button" onclick="showItemSelection()"></button>
      </div>
      <div id="item-selection">
        <button onclick="hideItemSelection()">Annuler</button>
      </div>
    </div>
  </div>
  <script type="module">
    // Importation des modules Firebase
    import {initializeApp} from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js';
    import {getPerformance} from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-performance.js';

    // Configuration Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyAwIIKfoYwdtFD63yKhVggZOAnooQion-M",
      authDomain: "willy0s-parallel-arena.firebaseapp.com",
      databaseURL: "https://willy0s-parallel-arena-default-rtdb.firebaseio.com",
      projectId: "willy0s-parallel-arena",
      storageBucket: "willy0s-parallel-arena.appspot.com",
      messagingSenderId: "683284732830",
      appId: "1:683284732830:web:ef7fb4cf1c88f73eead48f",
      measurementId: "G-85B8R4NKNM"
    };

    // Initialisation de Firebase
    const app = initializeApp(firebaseConfig);

    // Initialisation de Firebase Performance Monitoring
    const perf = getPerformance(app);
    if ('PerformanceObserver' in window) {
      // Créer un observateur pour les entrées de type "paint" (pour FCP)
      const paintObserver = new PerformanceObserver((list) => {
        const entries = list.getEntriesByName('first-contentful-paint');
        if (entries.length > 0) {
          const fcp = entries[0].startTime;
          console.log('First Contentful Paint (FCP):', fcp, 'ms');
        }
      });

      // Observer les événements de type "paint"
      paintObserver.observe({type: 'paint', buffered: true});

      // Créer un observateur pour les entrées de type "first-input" (pour FID)
      const fidObserver = new PerformanceObserver((list) => {
        const entries = list.getEntries();
        entries.forEach((entry) => {
          if (entry.entryType === 'first-input') {
            const fid = entry.processingStart - entry.startTime;
            console.log('First Input Delay (FID):', fid, 'ms');
          }
        });
      });

      // Observer les événements de type "first-input"
      fidObserver.observe({type: 'first-input', buffered: true});
    }
  </script>
  <script>


    // Déclaration globale des variables (elles seront accessibles partout)
    let playerCharacter = null;
    let opponentCharacter = null;
    let specialAbility = 0;

    // Détection du mode d'affichage (standalone ou non)
    if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true) {
      document.body.classList.add('web-app');
    } else {
      document.body.classList.add('normal-app');
    }

    // Récupère les données utilisateur depuis localStorage
    function getUserData() {
      let userData = localStorage.getItem('userData');
      if (userData) {
        try {
          userData = JSON.parse(userData);
        } catch (e) {
          console.error('Erreur lors du parsing de userData :', e);
          userData = {};
        }
        return userData;
      }
      return {}; // Retourne un objet vide si aucune donnée n'est trouvée
    }

    const userData = getUserData();
    console.log(userData.difficulty);

    // Sauvegarde les données utilisateur dans localStorage
    function saveUserData(userData) {
      localStorage.setItem('userData', JSON.stringify(userData));
      
    }

    // Chargement de la sauvegarde de partie depuis localStorage
    let sauvegarde = null;
    try {
      sauvegarde = JSON.parse(localStorage.getItem("savepartie"));
    } catch (e) {
      console.error('Erreur lors du parsing de la sauvegarde :', e);
    }
    if (sauvegarde) {
      console.log('Sauvegarde trouvée :', sauvegarde);
    }

    // Fonction qui charge les personnages depuis la sauvegarde
    function chargerPartie() {
      const sauvegardeLocal = JSON.parse(localStorage.getItem("savepartie"));
      if (!sauvegardeLocal) {
        console.warn("Aucune sauvegarde trouvée.");
        return;
      }
      // Affectation directe des objets sauvegardés aux variables globales
      playerCharacter = sauvegardeLocal.playerCharacter;
      opponentCharacter = sauvegardeLocal.opponentCharacter;

      console.log("Partie chargée avec succès !");
      updateUI(); // Mise à jour de l'interface après chargement
    }

    // Si une partie a déjà commencé et qu'une sauvegarde existe, on la charge
    if (userData.partie_commencee && sauvegarde) {
      chargerPartie();
    } else {
      // Sinon, on initialise les personnages à partir des données stockées en sessionStorage

      // Récupération et initialisation du personnage du joueur
      const storedPlayer = sessionStorage.getItem('playerCharacter');
      if (storedPlayer) {
        playerCharacter = JSON.parse(storedPlayer);

        // Initialisation des nouvelles propriétés
        playerCharacter.perte_att = 0;
        playerCharacter.Oiseaudefense = 0;
        playerCharacter.perte_defense_colorina = 0;
        playerCharacter.pv_maximum = playerCharacter.pv;
        playerCharacter.amulette_soin = 0;
        playerCharacter.attaque_epee = 0;
        playerCharacter.attaque_elixir = 0;
        playerCharacter.armure = 0;
        playerCharacter.degats_partie = 0;
        playerCharacter.objets_partie = 0;
        playerCharacter.capacite_partie = 0;
        playerCharacter.degats_partie_base = 0;
        playerCharacter.objets_soin = 0;
        playerCharacter.defense_bouton = 0;
        playerCharacter.defense_droit = 0;
        playerCharacter.defense_solide = 0;
        playerCharacter.defense_partie = 0;
        playerCharacter.immobilisation = 0;
        playerCharacter.sboonie_attaque = 0;
        playerCharacter.poulpy_att = 0;
        playerCharacter.objets_utilise = 0;
        playerCharacter.inventaire_objets = false;
        playerCharacter.amuletteUses = 0;
        playerCharacter.armureUses = 0;
        playerCharacter.tour = 1;
        playerCharacter.cape = false;
        playerCharacter.capeUses = 0;
        playerCharacter.crystalUses = 0;
        playerCharacter.inconnu_super = 0;
        playerCharacter.last_action = 0;
        playerCharacter.tourTT = 0;
      } else {
        // Rediriger vers index.html si les données du joueur ne sont pas trouvées
        window.location.href = 'index.html';
      }

      // Récupération et initialisation du personnage adverse
      const storedOpponent = sessionStorage.getItem('opponentCharacter');
      if (storedOpponent) {
        opponentCharacter = JSON.parse(storedOpponent);

        opponentCharacter.perte_att = 0;
        opponentCharacter.Oiseaudefense = 0;
        opponentCharacter.perte_defense_colorina = 0;
        opponentCharacter.pv_maximum = opponentCharacter.pv;
        opponentCharacter.immobilisation = 0;
        opponentCharacter.defense_bouton = 0;
        opponentCharacter.defense_droit = 0;
        opponentCharacter.sboonie_attaque = 0;
        opponentCharacter.poulpy_att = 0;
        opponentCharacter.degats_subit = 0;
        opponentCharacter.inconnu_super = 0;
        opponentCharacter.next_choice = "0";
        opponentCharacter.isDefending = false;
      } else {
        // Rediriger vers index.html si les données de l'adversaire ne sont pas trouvées
        window.location.href = 'index.html';
      }
    }

    console.log('Player Character :', playerCharacter);
    console.log('Opponent Character :', opponentCharacter);
    sauvegarderPartie(playerCharacter, opponentCharacter)

    // Empêche le retour en arrière dans l'historique du navigateur
    history.replaceState(null, null, window.location.href);

    console.log("good");

    // Initialisation de la capacité spéciale (on suppose que playerCharacter.spe existe)
    specialAbility = playerCharacter.spe || 0;

    // Mise à jour de l'interface utilisateur pour le joueur
    if (document.getElementById('player-name')) {
      document.getElementById('player-name').textContent = playerCharacter.name;
    }
    if (document.getElementById('player-pv')) {
      document.getElementById('player-pv').textContent = `PV: ${playerCharacter.pv}`;
    }

    // Mise à jour de l'interface utilisateur pour l'adversaire
    if (document.getElementById('opponent-name')) {
      document.getElementById('opponent-name').textContent = opponentCharacter.name;
    }
    if (document.getElementById('opponent-pv')) {
      document.getElementById('opponent-pv').textContent = `PV: ${opponentCharacter.pv}`;
    }

    // Fonction qui met à jour la barre de capacité spéciale
    function updateSpecialBar(character, elementId) {
      const specialBar = document.getElementById(elementId);
      if (!specialBar) return;
      const fillElement = specialBar.querySelector('.special-fill');
      if (!fillElement) return;
      const maxSpecialAbility = 1; // Valeur maximale de la capacité spéciale
      const widthPercentage = (character.spe / maxSpecialAbility) * 100;
      fillElement.style.width = `${widthPercentage}%`;
    }

    // Fonction qui met à jour l'interface globale (PV, noms, barres spéciales)
    function updateUI() {
      playerCharacter.pv = Math.round(playerCharacter.pv);
      opponentCharacter.pv = Math.round(opponentCharacter.pv);

      if (document.getElementById('player-name')) {
        document.getElementById('player-name').textContent = playerCharacter.name;
      }
      if (document.getElementById('player-pv')) {
        document.getElementById('player-pv').textContent = `PV: ${playerCharacter.pv}`;
      }
      updateSpecialBar(playerCharacter, 'player-special-bar');

      if (document.getElementById('opponent-name')) {
        document.getElementById('opponent-name').textContent = opponentCharacter.name;
      }
      if (document.getElementById('opponent-pv')) {
        document.getElementById('opponent-pv').textContent = `PV: ${opponentCharacter.pv}`;
      }
      updateSpecialBar(opponentCharacter, 'opponent-special-bar');
    }
    updateUI();

    // Fonction qui met à jour l'état du bouton de capacité spéciale
    function updateSpecialButton() {
      const specialButton = document.getElementById('special-button');
      if (!specialButton) return;
      const maxSpecialAbility = 1; // Valeur maximale

      if (specialAbility >= maxSpecialAbility) {
        specialButton.classList.add('bright');
        specialButton.classList.add('grow'); // Pour agrandir le bouton
        specialButton.textContent = 'Capacité spéciale';
      } else {
        specialButton.classList.remove('bright');
        specialButton.classList.remove('grow');
        specialButton.textContent = `${specialAbility.toFixed(1)} / 1`;
      }
    }
    updateSpecialButton();

    function updateTour() {
      const logColor = "grey";
      playerCharacter.tourTT += 1;
      console.log("Tour ", playerCharacter.tourTT);
      let specialLogMessage = "";
      specialLogMessage = 'Tour ' + playerCharacter.tourTT;
      addCombatLog(specialLogMessage, logColor, "milieu");

    }



    function adversairepasser_tour() {
      updateSpecialBar(opponentCharacter, 'opponent-special-bar');
      updateUI();
      if (opponentCharacter.inconnu_super >= 1) {
        opponentCharacter.inconnu_super -= 1;
      }
      if (opponentCharacter.immobilisation >= 1) {
        opponentCharacter.immobilisation -= 1;
      }
      if (opponentCharacter.defense_droit > 0) {
        opponentCharacter.defense_droit -= 1;
      }
      if (opponentCharacter.perte_att > 0) {
        opponentCharacter.perte_att -= 1;
        if (opponentCharacter.perte_att == 0) {
          opponentCharacter.attaque = Math.round(opponentCharacter.attaque / 0.75);
        }
      }
      if (opponentCharacter.poulpy_att > 0) {
        opponentCharacter.poulpy_att -= 1;
        if (opponentCharacter.poulpy_att == 0) {
          opponentCharacter.defense = Math.round(opponentCharacter.defense / 0.85);
        }
      }
      if (opponentCharacter.Oiseaudefense > 0) {
        opponentCharacter.Oiseaudefense -= 1;
        if (opponentCharacter.Oiseaudefense == 0) {
          opponentCharacter.defense -= 20;
        }
      }
      if (opponentCharacter.perte_defense_colorina > 0) {
        opponentCharacter.perte_defense_colorina -= 1;
        if (opponentCharacter.perte_defense_colorina == 0) {
          opponentCharacter.defense = Math.round(opponentCharacter.defense / 0.85);
        }
      }
      if (opponentCharacter.sboonie_attaque > 0) {
        opponentCharacter.sboonie_attaque -= 1;
        if (opponentCharacter.sboonie_attaque == 0) {
          opponentCharacter.attaque = Math.round(opponentCharacter.attaque / 0.85);
        }
      }
      sauvegarderPartie(playerCharacter, opponentCharacter);
    }


    function joueurpasser_tour() {
      updateSpecialBar(playerCharacter, 'player-special-bar');
      updateUI();
      playerCharacter.tour += 1;
      playerCharacter.inventaire_objets = false;
      playerCharacter.objets_utilise = 0;
      if (playerCharacter.inconnu_super >= 1) {
        playerCharacter.inconnu_super -= 1;
      }
      if (playerCharacter.cape) {
        playerCharacter.cape = false;
      }
      if (playerCharacter.immobilisation >= 1) {
        playerCharacter.immobilisation -= 1;
      }
      if (playerCharacter.amulette_soin > 0) {
        playerCharacter.pv = Math.round(playerCharacter.pv + (playerCharacter.pv_maximum * 0.02));
      }
      if (playerCharacter.defense_droit > 0) {
        playerCharacter.defense_droit -= 1;
      }
      if (playerCharacter.perte_att > 0) {
        playerCharacter.perte_att -= 1;
        if (playerCharacter.perte_att == 0) {
          playerCharacter.attaque = Math.round(playerCharacter.attaque / 0.75);
        }
      }
      if (playerCharacter.poulpy_att > 0) {
        playerCharacter.poulpy_att -= 1;
        if (playerCharacter.poulpy_att == 0) {
          playerCharacter.defense = Math.round(playerCharacter.defense / 0.85);
        }
      }
      if (playerCharacter.Oiseaudefense > 0) {
        playerCharacter.Oiseaudefense -= 1;
        if (playerCharacter.Oiseaudefense == 0) {
          playerCharacter.defense -= 20;
        }
      }
      if (playerCharacter.perte_defense_colorina > 0) {
        playerCharacter.perte_defense_colorina -= 1;
        if (playerCharacter.perte_defense_colorina == 0) {
          playerCharacter.defense = Math.round(playerCharacter.defense / 0.85);
        }
      }
      if (playerCharacter.sboonie_attaque > 0) {
        playerCharacter.sboonie_attaque -= 1;
        if (playerCharacter.sboonie_attaque == 0) {
          playerCharacter.attaque = Math.round(playerCharacter.attaque / 0.85);
        }
      }
      sauvegarderPartie(playerCharacter, opponentCharacter);

    }

    function showItemSelection() {
      const itemSelectionDiv = document.getElementById('item-selection');
      itemSelectionDiv.style.display = 'block';

      // Clear previous items
      itemSelectionDiv.innerHTML = '<h3>Choisissez un objet à utiliser</h3>';

      const userData = getUserData();
      const availableItems = [];

      // Vérifier si l'amulette de régénération a déjà été utilisée
      if (userData.crystal_acheté > 0 && playerCharacter.crystalUses < 2) {
        availableItems.push({
          name: 'Crystal de renouveau', count: userData.crystal_acheté
        });
      }
      if (userData.bouclier_solide_acheté > 0) {
        availableItems.push({name: 'Bouclier solide', count: userData.bouclier_solide_acheté});
      }
      if (userData.Cape_acheté > 0 && playerCharacter.capeUses < 2) {
        availableItems.push({name: "Cape de l'ombre", count: userData.Cape_acheté});
      }
      if (userData.Potion_de_Santé_acheté > 0) {
        availableItems.push({name: 'Potion de Santé', count: userData.Potion_de_Santé_acheté});
      }
      if (userData.armure_fer_acheté > 0 && playerCharacter.armureUses < 2) {
        // L'armure ne s'affiche plus si elle a été utilisée deux fois
        availableItems.push({name: 'Armure de Fer', count: userData.armure_fer_acheté});
      }
      if (userData.Amulette_de_Régénération_acheté > 0 && playerCharacter.amuletteUses < 1) {
        // L'amulette ne s'affiche plus si elle a été utilisée une fois
        availableItems.push({name: 'Amulette de Régénération', count: userData.Amulette_de_Régénération_acheté});
      }
      if (userData.epee_tranchante_acheté > 0) {
        availableItems.push({name: 'Épée Tranchante', count: userData.epee_tranchante_acheté});
      }
      if (userData.elixir_puissance_acheté > 0) {
        availableItems.push({name: 'Elixir de Puissance', count: userData.elixir_puissance_acheté});
      }


      // Si aucun objet n'a été utilisé
      if (playerCharacter.objets_utilise === 0) {
        // Si inventaire_objets est à false, on sélectionne 3 objets aléatoirement
        if (!playerCharacter.inventaire_objets) {
          playerCharacter.selectedItems = [];

          // Mélanger les items disponibles et en sélectionner 3
          const shuffledItems = availableItems.sort(() => 0.5 - Math.random());
          playerCharacter.selectedItems = shuffledItems.slice(0, 3);

          // Passer inventaire_objets à true pour se souvenir de la sélection
          playerCharacter.inventaire_objets = true;
        }

        // Afficher les 3 objets sélectionnés
        playerCharacter.selectedItems.forEach(item => {
          const itemButton = document.createElement('button');
          itemButton.textContent = `${item.name} (${item.count})`;
          itemButton.onclick = function () {useItem(item.name);};
          itemSelectionDiv.appendChild(itemButton);
        });

        // Ajouter le bouton Annuler
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Annuler';
        cancelButton.onclick = hideItemSelection;
        itemSelectionDiv.appendChild(cancelButton);

      } else if (playerCharacter.objets_utilise !== 0) {
        // Si des objets ont déjà été utilisés, proposer uniquement le bouton Annuler
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'Annuler';
        cancelButton.onclick = hideItemSelection;
        itemSelectionDiv.appendChild(cancelButton);
      }
    }

    function hideItemSelection() {
      document.getElementById('item-selection').style.display = 'none';
    }

    function useItem(itemName) {
      const userData = getUserData();
      playerCharacter.objets_utilise = 1;
      switch (itemName) {
        case 'Crystal de renouveau':
          userData.crystal_acheté -= 1;
          playerCharacter.crystalUses += 1;
          playerCharacter.spe += 0.8;
          if (playerCharacter.spe > 1) {
            playerCharacter.spe = 1;
          }
          saveUserData(userData);
          updateUI();
          break;
        case "Cape de l'ombre":
          userData.Cape_acheté -= 1;
          playerCharacter.capeUses += 1;
          playerCharacter.cape = true;
          saveUserData(userData);
          break;
        case 'Potion de Santé':
          userData.Potion_de_Santé_acheté -= 1;
          playerCharacter.pv += 1100;

          if (playerCharacter.pv > playerCharacter.pv_maximum) {
            playerCharacter.pv = playerCharacter.pv_maximum;
          }
          playerCharacter.objets_partie += 1;
          playerCharacter.objets_soin += 1;
          saveUserData(userData);
          break;

        case 'Amulette de Régénération':
          userData.Amulette_de_Régénération_acheté -= 1;
          // Amulette soin devient un effet permanent de régénération
          playerCharacter.amuletteUses += 1;
          playerCharacter.amulette_soin = 1; // On garde une régénération constante
          playerCharacter.objets_partie += 1;
          playerCharacter.objets_soin += 1;
          saveUserData(userData);
          break;

        case 'Épée Tranchante':
          userData.epee_tranchante_acheté -= 1;
          // Appliquer une augmentation permanente de l'attaque
          playerCharacter.attaque = Math.round(playerCharacter.attaque * 1.05); // Moins fort mais permanent
          playerCharacter.objets_partie += 1;
          saveUserData(userData);
          break;

        case 'Elixir de Puissance':
          userData.elixir_puissance_acheté -= 1;
          // L'effet reste permanent avec une augmentation modérée
          playerCharacter.attaque += 50; // Réduction de l'effet initial mais permanent
          playerCharacter.objets_partie += 1;
          saveUserData(userData);
          break;

        case 'Armure de Fer':
          userData.armure_fer_acheté -= 1;
          // Réduire l'attaque de l'adversaire de façon permanente
          playerCharacter.armureUses += 1;
          opponentCharacter.attaque = Math.round(opponentCharacter.attaque * 0.90); // Moins d'effet mais permanent
          playerCharacter.objets_partie += 1;
          saveUserData(userData);
          break;

        case 'Bouclier solide':
          userData.bouclier_solide_acheté -= 1;
          // Appliquer une augmentation permanente de la défense
          playerCharacter.defense += 15; // Réduit l'effet initial mais permanent
          playerCharacter.objets_partie += 1;
          saveUserData(userData);
          break;

        default:
          console.log('Objet non reconnu');
      }

      // Mettre à jour l'interface utilisateur

      document.getElementById('player-pv').textContent = `PV: ${playerCharacter.pv}`;

      // Masquer la sélection des objets
      hideItemSelection();

      const logColor = 'white';

      // Ajoute une entrée dans le journal de combat

      specialLogMessage = `${itemName} utilisé !`;
      addCombatLog(specialLogMessage, logColor, 'milieu');

      scrollToBottom(); // Assurez-vous que la vue défile vers le bas
    }

    function addCombatLog(message, color, isPlayer) {
      const combatLog = document.getElementById('combat-log');
      const logEntry = document.createElement('p');
      logEntry.textContent = message;
      logEntry.style.color = color;
      // Définir l'alignement selon l'origine de l'action
      if (isPlayer === true) {
        logEntry.style.textAlign = "left";     // Action du joueur → à gauche
      } else if (isPlayer === false) {
        logEntry.style.textAlign = "right";    // Action de l'adversaire → à droite
      } else {
        logEntry.style.textAlign = "center";   // Sinon → au centre
      }
      combatLog.appendChild(logEntry);
    }



    function useSpecialAbility(character, opponent, isPlayer) {
      if (character.spe < 1) {
        const specialLogMessage = `${character.name} à tenté d'utiliser sa capacité spéciale, mais n'avait pas assez d'énergie, il va donc attaquer`;
        addCombatLog(specialLogMessage, "white", "left");
        handleAttack(character, opponent, isPlayer);
      }
      if (character.spe >= 1) {
        // Décrémente la quantité de la capacité spéciale utilisée
        character.spe -= 1;
        if (isPlayer) {
          specialAbility -= 1;
          character.capacite_partie += 1;
          character.last_action = 2;
        }

        // Choix de la couleur du log en fonction du joueur ou de l'adversaire
        const logColor = 'white';
        let specialLogMessage = "";

        if (character.immobilisation >= 1) {
          specialLogMessage = `${character.name} utilise sa capacité spéciale ! Mais ${opponent.name} l'a immobilisé, donc l'attaque échoue et rien ne se passe.`;
          opponent.pv -= 0;
          addCombatLog(specialLogMessage, logColor, isPlayer);
        } else if (opponent.defense_bouton === 1) {
          opponent.defense_bouton = 0;
          specialLogMessage = `${character.name} utilise sa capacité spéciale ! Mais ${opponent.name} l'en empêche, donc l'attaque échoue et rien ne se passe.`;
          opponent.pv -= 0;
          addCombatLog(specialLogMessage, logColor, isPlayer);
        } else if (character.inconnu_super >= 1) {
          specialLogMessage = `${character.name} ne peut pas utiliser sa capacité spéciale, car ${opponent.name} l'a bloqué pour encore ${character.inconnu_super} tours.`;
          character.spe += 1;
          addCombatLog(specialLogMessage, logColor, isPlayer);
          handleAttack(character, opponent, isPlayer);
        } else if (isPlayer && opponent.nextAction === "se défendre") {
          specialLogMessage = `${character.name} utilise sa capacité spéciale ! Mais ${opponent.name} l'en empêche !`;

          addCombatLog(specialLogMessage, logColor, isPlayer)
          opponentTurn();
        } else {
          switch (character.name) {
            case "Diva":
              opponent.attaque *= 0.75;
              character.spe -= 0.25;
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! L'attaque de ${opponent.name} est réduite à ${Math.round(opponent.attaque.toFixed(2))} pour les 3 prochains tours.`;
              opponent.perte_att += 3;
              if (!isPlayer) {
                opponent.perte_att += 1;
              }
              addCombatLog(specialLogMessage, logColor, isPlayer);
              handleAttack(character, opponent, isPlayer);
              break;

            case "Willy":
              character.spe -= 0.25;
              specialAbility -= 0.25;
              const opponentDefenseModifiee = 0.9 + Math.random() * 0.2; // Entre 0.9 et 1.1
              const opponentDefensee = Math.round(opponent.defense * opponentDefenseModifiee);
              opponent.pv += (2 * (opponentDefensee - character.attaque));
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il effectue 3 attaques !\n\n${character.name} attaque ${opponent.name} et inflige ${Math.round(2 * (character.attaque - opponentDefensee))} points de dégâts.`;
              character.degats_partie += (2 * (character.attaque - opponentDefensee));
              addCombatLog(specialLogMessage, logColor, isPlayer);
              handleAttack(character, opponent, isPlayer);
              character.last_action = 2;
              break;

            case "Baleine":
              if (character.defense < 29) {
                specialLogMessage = "Baleine n'a plus assez de défense pour utiliser sa capacité spéciale, il va donc attaquer.";

                addCombatLog(specialLogMessage, logColor, isPlayer);

                handleAttack(character, opponent, isPlayer);
              } else {
                specialLogMessage = "Baleine utilise sa capacité spéciale ! Il perd 15 de défense et gagne 1000 PV !";
                addCombatLog(specialLogMessage, logColor, isPlayer);
                character.spe -= 0.25;
                if (isPlayer) {
                  specialAbility -= 0.25;
                }
                character.defense -= 15;
                character.pv += 1000;



                handleAttack(character, opponent, isPlayer);
              }
              break;

            case "Doudou":
              character.spe -= 0.25;
              let regeneratedAmount;
              if (character.pv < (character.pv_max / 2)) {
                regeneratedAmount = Math.ceil(character.pv * 0.15);
                specialLogMessage = `${character.name} utilise sa capacité spéciale ! Elle régénère ${Math.round(regeneratedAmount)} PV.`;
                character.pv += regeneratedAmount;
                if (character.pv > character.pv_max) {
                  character.pv = character.pv_max;
                }
                addCombatLog(specialLogMessage, logColor, isPlayer);
                handleAttack(character, opponent, isPlayer);
                updateSpecialBar(playerCharacter, 'player-special-bar');
                updateSpecialBar(opponentCharacter, 'opponent-special-bar');
              } else {
                regeneratedAmount = Math.ceil(character.pv * 0.05);
                specialLogMessage = `${character.name} utilise sa capacité spéciale ! Elle régénère ${Math.round(regeneratedAmount)} PV.`;
                character.pv += regeneratedAmount;
                if (character.pv > character.pv_max) {
                  character.pv = character.pv_max;
                }
                addCombatLog(specialLogMessage, logColor, isPlayer);
                handleAttack(character, opponent, isPlayer);
                updateSpecialBar(playerCharacter, 'player-special-bar');
                updateSpecialBar(opponentCharacter, 'opponent-special-bar');
              }
              break;

            case "Cocobi":
              const reductionAmount = Math.ceil(opponent.pv_maximum * 0.12);
              opponent.pv -= reductionAmount;
              if (opponent.pv < 0) {
                opponent.pv = 0;
              }
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! ${opponent.name} perd ${Math.round(reductionAmount)} PV.`;
              character.degats_partie += reductionAmount;
              addCombatLog(specialLogMessage, logColor, isPlayer);

              break;

            case "Coeur":
              const specialDamage = Math.round(character.attaque * 1.5);
              const absorbedHealth = Math.round(specialDamage * (character.pv > (character.pv_max / 2) ? 0.1 : 0.15));
              opponent.pv -= specialDamage;
              character.pv += absorbedHealth;
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(specialDamage)} points de dégâts et récupère ${Math.round(absorbedHealth)} PV.`;
              character.degats_partie += specialDamage;
              if (opponent.pv < 0) opponent.pv = 0;
              if (character.pv > character.pv_max) character.pv = character.pv_max;

              // Ajouter le message au journal
              addCombatLog(specialLogMessage, logColor, isPlayer);
              break;

            case "Grours":
              const Damage = 500 + character.attaque;
              const defense = Math.round(opponent.defense * 0.5);
              opponent.pv -= (Damage - defense);
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(Damage - defense)} points de dégâts à ${opponent.name}, ignorant le bouclier.`;
              character.degats_partie += (Damage - defense);

              addCombatLog(specialLogMessage, logColor, isPlayer);
              break;

            case "Poulpy":
              const poulpyDamage = Math.round(character.attaque * 1.75);
              const effectiveDefense = Math.round(opponent.defense * 0.6);
              const netDamage = Math.max(0, poulpyDamage - effectiveDefense);
              opponent.pv -= netDamage;
              opponent.defense *= 0.85;
              opponent.poulpy_att += 3;
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(netDamage)} points de dégâts à ${opponent.name}, ignore 50% de sa défense et réduit sa défense de 15% pour les 2 prochains tours.`;
              character.degats_partie += netDamage;

              addCombatLog(specialLogMessage, logColor, isPlayer);
              break;

            case "Oiseau":
              const DamageOiseau = character.attaque * 2.5;
              character.defense += 20;
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(DamageOiseau)} points de dégâts et gagne 20 de défense.`;
              opponent.pv -= DamageOiseau;
              character.Oiseaudefense += 2;
              character.degats_partie += DamageOiseau;

              // Ajouter le message au journal
              addCombatLog(specialLogMessage, logColor, isPlayer);
              break;

            case "Colorina":
              const colorinaDamage = Math.round(character.attaque * 0.85);
              opponent.pv -= colorinaDamage;
              opponent.defense *= 0.85;
              opponent.perte_defense_colorina += 4;
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il inflige ${Math.round(colorinaDamage)} points de dégâts et réduit la défense de ${opponent.name} de 15% pour les 3 prochains tours.`;
              character.degats_partie += colorinaDamage;

              // Ajouter le message au journal
              addCombatLog(specialLogMessage, logColor, isPlayer);
              break;
            case "Rosalie":
              const rosalieDamage = Math.round(character.attaque * 2);
              const immobilizationChance = Math.random();
              if (immobilizationChance < 0.25) {
                opponent.immobilisation = 1; // Marque l'adversaire comme immobilisé
                specialLogMessage = `${character.name} utilise sa capacité spéciale ! Elle inflige ${Math.round(rosalieDamage)} points de dégâts et immobilise ${opponent.name} pour un tour.`;
              } else {
                specialLogMessage = `${character.name} utilise sa capacité spéciale ! Elle inflige ${Math.round(rosalieDamage)} points de dégâts.`;
              }
              opponent.pv -= rosalieDamage;
              if (opponent.pv < 0) opponent.pv = 0;
              character.degats_partie += rosalieDamage;
              addCombatLog(specialLogMessage, logColor, isPlayer);

              break;
            case "Sboonie":
              pvsupp = Math.round(character.pv_max * 0.08)
              character.pv += pvsupp;
              opponent.pv -= 50;
              opponent.attaque = Math.round(opponent.attaque * 0.85);
              if (!isPlayer) {
                opponent.sboonie_attaque += 1;
              }
              opponent.sboonie_attaque += 1;
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Il régénère ${Math.round(pvsupp)} PV, inflige 50 de dégâts et reduit de 15% l'attaque de ${opponent.name} pour le prochain tour.`;
              addCombatLog(specialLogMessage, logColor, isPlayer);

              break;

            case 'Inconnu':
              character.spe -= 0.25;
              opponent.inconnu_super += 3;
              if (isPlayer) {
                opponent.inconnu_super += 1;
              }
              character.attaque += 25;
              character.defense += 25;
              specialLogMessage = `${character.name} utilise sa capacité spécial, il augmente son attaque et sa défense de 15 et ${opponent.name} ne peut pas utiliser sa capacité spéciale pendant 3 tours !`;
              addCombatLog(specialLogMessage, logColor, isPlayer);
              handleAttack(character, opponent, isPlayer);
              break;

            default:
              specialLogMessage = `${character.name} utilise sa capacité spéciale ! Effet spécifique à définir.`;
              addCombatLog(specialLogMessage, logColor, isPlayer);
          }
        }

        // Met à jour l'affichage des PV du joueur ou de l'adversaire
        document.getElementById(isPlayer ? 'player-pv' : 'opponent-pv').textContent = `PV: ${character.pv}`;

        // Met à jour le bouton après l'utilisation si c'est le joueur
        character.last_action = 2;
        updateSpecialButton();
        updateSpecialBar(playerCharacter, 'player-special-bar');
        updateSpecialBar(opponentCharacter, 'opponent-special-bar');
        updateUI();

        scrollToBottom();
        if (isPlayer && character.name != "Diva" && character.name != "Willy" && character.name != "Baleine" && character.name != "Doudou") {
          opponentTurn();
        }
      }
    }



    // --------------------------
    // Fonctions utilitaires déjà existantes
    // --------------------------


    // Calcule la distance de Manhattan entre deux tableaux numériques


    // Historique des actions du joueur (ordre chronologique)
    function loadPlayerActionHistory() {
      const data = localStorage.getItem("playerActionHistory");
      return data ? JSON.parse(data) : [];
    }

    // Fonction pour sauvegarder l'historique des actions du joueur dans le localStorage
    function savePlayerActionHistory(history) {
      localStorage.setItem("playerActionHistory", JSON.stringify(history));
    }

    // Historique des actions du joueur (ordre chronologique)
    // On vérifie s'il existe déjà dans le localStorage ; sinon, on initialise un tableau vide.
    let playerActionHistory = loadPlayerActionHistory();


    function manhattanDistance(arr1, arr2) {
      let distance = 0;
      for (let i = 0; i < arr1.length; i++) {
        distance += Math.abs(arr1[i] - arr2[i]);
      }
      return distance;
    }

    // Sélection aléatoire pondérée parmi un objet d'actions et d'occurrences
    function weightedRandomAction(actionCounts) {
      const total = Object.values(actionCounts).reduce((sum, count) => sum + count, 0);
      let rand = Math.random() * total;
      for (let action in actionCounts) {
        rand -= actionCounts[action];
        if (rand <= 0) {
          return action;
        }
      }
      return null;
    }

    // Recherche des états similaires dans l'historique (on ignore l'action du joueur, index 3)
    // Dictionnaire de correspondance pour l'action du joueur
    const actionMapping = {
      "attacker": 0,
      "se défendre": 1,
      "utiliser capacité spéciale": 2
    };

    // Transforme un état en remplaçant l'action (index 3) par sa valeur numérique
    function transformState(state) {
      // Copie de l'état
      let newState = state.slice();
      // On remplace la valeur à l'index 3 si c'est une chaîne et qu'on a une correspondance
      if (typeof newState[3] === "string" && actionMapping[newState[3]] !== undefined) {
        newState[3] = actionMapping[newState[3]];
      } else {
        newState[3] = 0; // valeur par défaut en cas de problème
      }
      return newState;
    }

    // Version améliorée de findSimilarData qui inclut l'action du joueur
    function findSimilarData(currentState, data, similarityThreshold = 2) {
      const stateToMatch = transformState(currentState);
      return data.filter(row => {
        const rowState = transformState(row);
        return manhattanDistance(stateToMatch, rowState) <= similarityThreshold;
      });
    }


    // Retourne l'action la plus probable à partir d'un ensemble de données similaires
    function mostProbableAction(data) {
      // Tente de prédire via la séquence d'actions (ordre 2 ici, ajustable)
      let sequencePrediction = predictPlayerNextActionBySequence(2);
      if (sequencePrediction !== null) {
        console.log("Prédiction par séquence trouvée :", sequencePrediction);
        return sequencePrediction;
      }

      // Sinon, utilise la méthode actuelle basée sur la pondération des actions dans les états similaires
      if (data.length === 0) return null;
      const actions = data.map(row => row[3]); // l'action du joueur à l'index 3
      const counts = actions.reduce((acc, action) => {
        acc[action] = (acc[action] || 0) + 1;
        return acc;
      }, {});
      return weightedRandomAction(counts);
    }

    // Sauvegarde et chargement de l'historique via localStorage
    function saveHistoricalData(data) {
      localStorage.setItem("historicalData", JSON.stringify(data));
    }

    function loadHistoricalData() {
      const data = localStorage.getItem("historicalData");
      return data ? JSON.parse(data) : [];
    }

    // Chargement initial de l'historique
    const historicalData = loadHistoricalData();

    // ---------------------------------------------------------------------
    // Gestion adaptative par situation : statistiques par situation/action
    // ---------------------------------------------------------------------
    //
    // Pour chaque situation, nous enregistrons l'efficacité de chaque action
    // sous forme de delta (variation des points de vie du joueur et de l'IA).
    //
    // La situation est identifiée par les indicateurs suivants extraits de l'état :
    // - Disponibilité de la capacité spéciale du joueur (Jcs)
    // - Possibilité de se défendre du joueur (Jdefense)
    // - Indicateur de défense active (playerIsDefending)
    // - Pourcentage de vie du joueur (Jpv)
    // - Disponibilité de la capacité spéciale de l'IA (IAcs)
    // - Pourcentage de vie de l'IA (IApv)
    //
    const situationStats = {}; // Structure : { situationKey: { action: { totalDelta, count } } }
    let lastState = null;          // État du tour précédent (tableau)
    let lastAIAction = null;       // Action exécutée lors du tour précédent
    let lastSituationKey = null;   // Clé de situation du tour précédent

    // Pour calculer le delta effectif, nous utilisons également les PV réels
    let lastPlayerHP = null;
    let lastAIHP = null;

    // Construit une clé de situation à partir de l'état et de l'information de défense active du joueur
    function getSituationKey(state, playerIsDefending) {
      // state = [Jcs, Jdefense, Jpv, Jaction, IAcs, IAdefense, IApv]
      // Pour l'enregistrement de la situation, on retire les informations sur les PV (Jpv et IApv)
      // On conserve ainsi uniquement : Jcs, Jdefense, activeDef, IAcs et IAdefense.
      return `Jcs:${state[0]}_Jdef:${state[1]}_activeDef:${playerIsDefending ? 1 : 0}_IAcs:${state[4]}_IAdef:${state[5]}`;
    }


    // --------------------------
    // Système de décision de l'IA (évaluation) avec données détaillées
    // --------------------------

    /*
     * La fonction evaluateAction attribue un score à une option (action)
     * en fonction de l'état courant, d'une éventuelle action prédite du joueur,
     * du modificateur de difficulté et de l'état défensif du joueur.
     *
     * L'état est un tableau : [Jcs, Jdefense, Jpv, Jaction, IAcs, IAdefense, IApv]
     *
     * Ici, nous ajoutons également les données réelles (charge spéciale, attaque de base,
     * pourcentage précis de vie) pour affiner l'analyse.
     */
    function evaluateAction(state, action, predictedPlayerAction, difficultyModifier, playerIsDefending) {
      // Déstructuration de l'état normalisé
      const [Jcs, Jdefense, Jpv, JlastAction, IAcs, IAdefense, IApv] = state;
      let score = 0;

      // Récupération des données détaillées (inchangées)
      const JpvPrecise = Math.round((playerCharacter.pv / playerCharacter.pv_max) * 100);
      const IApvPrecise = Math.round((opponentCharacter.pv / opponentCharacter.pv_max) * 100);
      const playerAttack = playerCharacter.attaque;
      const opponentAttack = opponentCharacter.attaque;
      const playerSpecialCharge = playerCharacter.spe;
      const opponentSpecialCharge = opponentCharacter.spe;

      // --- Évaluation de l'action "attacker" ---
      if (action === "attacker") {
        score += (100 - JpvPrecise) * 0.2;
        if (predictedPlayerAction === "attacker") {
          score += 5;
          score -= playerAttack * 0.1;
        }
        if (predictedPlayerAction === "utiliser capacité spéciale") {
          score -= 15;
        }
        if (difficultyModifier > 0) {
          if (Jdefense === 1) score -= 10;
          if (predictedPlayerAction === "se défendre" && IApv > 50) score += 5;
          if (JlastAction === "utiliser capacité spéciale") score += 5;
        }
        score += opponentAttack * 0.05;
      }
      // --- Évaluation de l'action "utiliser capacité spéciale" ---
      else if (action === "utiliser capacité spéciale") {
        score += (100 - JpvPrecise) * 0.35;
        score += opponentSpecialCharge * 10;
        if (playerSpecialCharge < 0.2) {
          score += 5;
        } else {
          score -= playerSpecialCharge * 5;
        }
        if (predictedPlayerAction === "se défendre") {
          score -= 20;
        }
        if (difficultyModifier > 0) {
          if (Jdefense === 1 || predictedPlayerAction === "se défendre") score -= 25;
          if (playerCharacter.specialCharge && playerCharacter.specialCharge > 0.25) score -= 15;
          if (JlastAction === "utiliser capacité spéciale") score -= 5;
        }
        score += opponentAttack * 0.2;
      }
      // --- Évaluation de l'action "se défendre" ---
      else if (action === "se défendre") {
        if (predictedPlayerAction === "attacker") {
          score += 12;
          score += playerAttack * 0.2;
        }
        if (predictedPlayerAction === "utiliser capacité spéciale") {
          score += 35;
        }
        // *** BONUS AJOUTÉ : Si le joueur peut utiliser sa capacité spéciale (Jcs === 1),
        // l'IA renforce la défense car il y a de fortes chances que le joueur l'utilise.
        if (Jcs === 1) {
          score += 30;
          console.log("Bonus défense car le joueur peut utiliser sa capacité spéciale");
        }
        score += JpvPrecise * 0.1;
        if (difficultyModifier > 0) {
          if (Jcs === 0 && playerCharacter.specialCharge && playerCharacter.specialCharge > 0.5 && IApv > 30) score -= 20;
          if (JlastAction === "attacker" && Jpv > 60) score -= 10;
          if (IApv < 30) score += 15;
          if (JlastAction === "se défendre") score -= 5;
        }
      }

      score += difficultyModifier * 10;
      if (IApv < 50 && action === "se défendre") {
        score += 12;
      }

      // Bonus adaptatif en fonction de la situation (inchangé)
      const situationKey = getSituationKey(state, playerIsDefending);
      if (situationStats[situationKey] &&
        situationStats[situationKey][action] &&
        situationStats[situationKey][action].count > 0) {
        let avgDelta = situationStats[situationKey][action].totalDelta / situationStats[situationKey][action].count;
        // On augmente le coefficient pour un impact plus fort :
        score += avgDelta * 0.5;
        console.log(`Bonus adaptatif pour l'action "${action}" dans la situation ${situationKey}: avgDelta = ${avgDelta}, bonus = ${avgDelta * 0.5}`);
      }

      return score;
    }

    /*
     * Choisit la meilleure action possible.
     * Sur Easy, une part d'aléatoire est introduite pour simuler une IA moins prévisible.
     */
    function chooseBestAction(IA, state, predictedPlayerAction, difficultyModifier, playerIsDefending) {
      const possibleActions = ["attacker"];
      // Ici, on utilise la charge spéciale réelle pour décider si l'IA peut utiliser sa capacité spéciale
      if (opponentCharacter.spe >= 1) {
        possibleActions.push("utiliser capacité spéciale");
      }
      if (!opponentCharacter.defenseCooldown || opponentCharacter.defenseCooldown === 0 && opponentCharacter.spe >= 0.1) {
        possibleActions.push("se défendre");
      }

      let bestAction = possibleActions[0];
      let bestScore = -Infinity;
      possibleActions.forEach(action => {
        const score = evaluateAction(state, action, predictedPlayerAction, difficultyModifier, playerIsDefending);
        console.log(`Action "${action}" -> score ${score}`);
        if (score > bestScore) {
          bestScore = score;
          bestAction = action;
        }
      });

      if (userData.difficulty === "Easy" && Math.random() < 0.3) {
        bestAction = possibleActions[Math.floor(Math.random() * possibleActions.length)];
        console.log("Difficulté Easy : choix aléatoire de l'action", bestAction);
      }

      return bestAction;
    }

    // --------------------------
    // Exécution du tour de l'IA avec une action prédéfinie
    // --------------------------

    function executeAITurn(chosenAction) {
      const delay = Math.floor(Math.random() * 2000) + 1000; // Génère un délai entre 1000ms (1s) et 3000ms (3s)

      setTimeout(() => {
        console.log("L'IA exécute l'action planifiée :", chosenAction);
        if (chosenAction === "attacker") {
          handleAttack(opponentCharacter, playerCharacter, false);
        } else if (chosenAction === "utiliser capacité spéciale" && opponentCharacter.spe === 1) {
          useSpecialAbility(opponentCharacter, playerCharacter, false);
        } else if (chosenAction === "se défendre") {
          opponentDefense();
          opponentCharacter.defenseCooldown = 3;
        } else {
          handleAttack(opponentCharacter, playerCharacter, false)
        }
        document.getElementById('attack-button').disabled = false;
        document.getElementById('special-button').disabled = false;
        document.getElementById('defense-button').disabled = false;
        document.getElementById('items-button').disabled = false;
        sauvegarderPartie(playerCharacter, opponentCharacter);
      }, delay);
    }

    function arraysEqual(a, b) {
      if (a.length !== b.length) return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) return false;
      }
      return true;
    }

    function predictPlayerNextActionBySequence(order = 2) {
      // Si l'historique des actions est trop court, on ne peut pas prédire
      if (playerActionHistory.length < order) return null;
      // Récupère les 'order' dernières actions du joueur
      const sequence = playerActionHistory.slice(-order);
      const counts = {};

      // On parcourt l'historique (historicalData) qui contient les états chronologiques
      // Chaque état est un tableau où l'action du joueur est à l'index 3.
      for (let i = 0; i <= historicalData.length - order - 1; i++) {
        // Extrait la séquence d'actions de longueur 'order' à partir de l'historique
        let histSequence = [];
        for (let j = 0; j < order; j++) {
          histSequence.push(historicalData[i + j][3]);
        }
        // Compare la séquence extraite à celle courante
        if (arraysEqual(histSequence, sequence)) {
          // Si possible, récupère l'action qui suit cette séquence
          if (i + order < historicalData.length) {
            let nextAction = historicalData[i + order][3];
            counts[nextAction] = (counts[nextAction] || 0) + 1;
          }
        }
      }

      if (Object.keys(counts).length === 0) return null;
      return weightedRandomAction(counts);
    }

    // --------------------------
    // Gestion des tours de l'adversaire (IA)
    // --------------------------

    function opponentTurn() {

      document.getElementById('attack-button').disabled = true;
      document.getElementById('special-button').disabled = true;
      document.getElementById('defense-button').disabled = true;
      document.getElementById('items-button').disabled = true;


      // Gestion du cooldown de défense pour l'IA (inchangé)
      if (typeof opponentCharacter.defenseCooldown === 'undefined') {
        opponentCharacter.defenseCooldown = 0;
      } else if (opponentCharacter.defenseCooldown > 0) {
        opponentCharacter.defenseCooldown--;
      }

      // Construction de l'état courant (inchangé)
      let Jdefense = (playerCharacter.defense_droit >= 1) ? 1 : 0;
      let Jcs = (playerCharacter.spe >= 1) ? 1 : 0;
      let Jpv = Math.min(Math.ceil((playerCharacter.pv / playerCharacter.pv_max) * 100 / 20) * 20, 100);
      let Jaction = playerCharacter.last_action;
      let IAdefense = (opponentCharacter.defense_droit >= 1) ? 1 : 0;
      let IAcs = (opponentCharacter.spe >= 1) ? 1 : 0;
      let IApv = Math.min(Math.ceil((opponentCharacter.pv / opponentCharacter.pv_max) * 100 / 20) * 20, 100);
      playerActionHistory.push(Jaction);
      // On conserve uniquement les 30 dernières actions
      if (playerActionHistory.length > 30) {
        playerActionHistory = playerActionHistory.slice(-30);
      }
      savePlayerActionHistory(playerActionHistory);
      const currentState = [Jcs, Jdefense, Jpv, Jaction, IAcs, IAdefense, IApv];
      console.log("État courant :", currentState);

      const playerIsDefending = (playerCharacter.defense_droit === 4);
      const currentSituationKey = getSituationKey(currentState, playerIsDefending);

      // Mise à jour des statistiques de la situation précédente (inchangé)
      let currentPlayerHP = playerCharacter.pv;
      let currentAIHP = opponentCharacter.pv;
      if (
        lastSituationKey !== null &&
        lastAIAction !== null &&
        lastState !== null &&
        lastPlayerHP !== null &&
        lastAIHP !== null
      ) {
        let deltaPlayer = lastPlayerHP - currentPlayerHP;
        let deltaAI = lastAIHP - currentAIHP;
        let effectiveDelta = deltaPlayer - deltaAI;
        if (Math.abs(effectiveDelta) < 100) {
          effectiveDelta = 0;
        }
        if (!situationStats[lastSituationKey]) {
          situationStats[lastSituationKey] = {
            "attacker": {totalDelta: 0, count: 0},
            "utiliser capacité spéciale": {totalDelta: 0, count: 0},
            "se défendre": {totalDelta: 0, count: 0}
          };
        }
        situationStats[lastSituationKey][lastAIAction].totalDelta += effectiveDelta;
        situationStats[lastSituationKey][lastAIAction].count++;
        console.log(`Mise à jour de l'efficacité pour l'action "${lastAIAction}" dans la situation ${lastSituationKey} : deltaPlayer = ${deltaPlayer}, deltaAI = ${deltaAI}, effectiveDelta = ${effectiveDelta}, nouvelle moyenne = ${situationStats[lastSituationKey][lastAIAction].totalDelta / situationStats[lastSituationKey][lastAIAction].count}`);
      }

      // Choix de l'action planifiée pour ce tour (inchangé)
      let currentAction = opponentCharacter.nextAction;
      if (!currentAction) {
        const possibleActions = ["attacker"];
        if (opponentCharacter.spe >= 0.8) possibleActions.push("utiliser capacité spéciale");
        if (!opponentCharacter.defenseCooldown || opponentCharacter.defenseCooldown === 0) possibleActions.push("se défendre");
        currentAction = possibleActions[Math.floor(Math.random() * possibleActions.length)];
      }
      console.log("Action planifiée pour ce tour :", currentAction);
      executeAITurn(currentAction);

      // Mise à jour de l'historique (inchangé)
      historicalData.push(currentState);
      saveHistoricalData(historicalData);

      // Paramètres de difficulté (inchangé)
      let difficultyModifier = 0;
      let predictionAccuracy = 0.75;
      if (userData.difficulty === "Easy") {
        difficultyModifier = -0.2;
        predictionAccuracy = 0.5;
      } else if (userData.difficulty === "Hard") {
        difficultyModifier = 0.2;
        predictionAccuracy = 1;
      }

      // --- Prédiction de l'action du joueur ---
      const similarData = findSimilarData(currentState, historicalData);
      let predictedPlayerAction = mostProbableAction(similarData);
      if (Math.random() > predictionAccuracy) {
        predictedPlayerAction = null;
        console.log("Prédiction ignorée (difficulté moindre)");
      }
      // *** Modification : Si le joueur peut utiliser sa capacité spéciale (Jcs === 1),
      // on force la prédiction pour indiquer qu'il utilisera sa capacité spéciale.

      console.log("Action prédite du joueur pour le prochain tour :", predictedPlayerAction);

      // Planification du prochain coup de l'IA
      const nextAction = chooseBestAction(opponentCharacter, currentState, predictedPlayerAction, difficultyModifier, playerIsDefending);
      console.log("Action planifiée pour le prochain tour :", nextAction);
      opponentCharacter.nextAction = nextAction;

      // Stockage de l'état, de la situation et des PV réels pour la prochaine mise à jour
      lastState = currentState;
      lastAIAction = currentAction;
      lastSituationKey = currentSituationKey;
      lastPlayerHP = currentPlayerHP;
      lastAIHP = currentAIHP;

      // Passage au tour suivant après un délai (inchangé)

      adversairepasser_tour();
      joueurpasser_tour();
      updateSpecialBar(playerCharacter, 'player-special-bar');
      updateSpecialBar(opponentCharacter, 'opponent-special-bar');
      updateUI();
    }














    function opponentDefense() {
      opponentCharacter.isDefending = true;
      opponentCharacter.spe -= 0.1;
      const isPlayer = false;
      opponentCharacter.defense_droit = 4;

      const soin = Math.round(opponentCharacter.degats_subit * 0.8)
      attaque = opponentCharacter.attaque;
      opponentCharacter.attaque = Math.round(opponentCharacter.attaque * 0.8);
      opponentCharacter.pv += soin;

      specialLogMessage = `${opponentCharacter.name} se defend de la dernière attaque de ${playerCharacter.name}.`;
      logColor = 'white';
      updateSpecialBar(playerCharacter, 'player-special-bar');
      updateSpecialBar(opponentCharacter, 'opponent-special-bar');
      addCombatLog(specialLogMessage, logColor, isPlayer);
      scrollToBottom();

      handleAttack(opponentCharacter, playerCharacter, false)
      opponentCharacter.attaque = attaque;

    }

    function handleDefense(character, opponent, isPlayer) {


      const logColor = 'white';
      if (character.defense_droit === 0) {
        if (character.spe >= 0.1) {
          character.spe -= 0.1;
          character.defense_bouton = 1;
          character.defense_droit = 4;
          specialLogMessage = `${character.name} se defend contre la prochaine attaque de ${opponent.name}.`;
          addCombatLog(specialLogMessage, logColor, isPlayer);
          if (isPlayer) {
            character.last_action = 1;
            character.defense_partie += 1;
            opponentTurn();
          }
        } else {
          specialLogMessage = `${character.name} n'a pas assez d'énergie spéciale pour se défendre !`;
          addCombatLog(specialLogMessage, logColor, isPlayer);
          handleAttack(character, opponent, true)
        }

      } else if (isPlayer) {
        specialLogMessage = `${character.name} ne peut pas se défendre avant dans ${character.defense_droit} tours.`;
        addCombatLog(specialLogMessage, logColor, isPlayer);
        handleAttack(character, opponent, true)
      } else if (!isPlayer) {
        specialLogMessage = `${character.name} ne peut pas se défendre avant dans ${character.defense_droit} tours.`;
        addCombatLog(specialLogMessage, logColor, isPlayer);
      }
      updateSpecialBar(playerCharacter, 'player-special-bar');
      updateSpecialBar(opponentCharacter, 'opponent-special-bar');
      updateUI();
    }

    function handleAttack(attacker, defender, isPlayer) {

      const isPlayerAttacking = isPlayer;

      const logColor = 'white';
      // Augmenter spe de 0.25 à chaque attaque
      if (isPlayerAttacking) {
        specialAbility = attacker.spe;
        attacker.last_action = 0;
      }

      if (isPlayerAttacking && attacker.spe < 0) {
        attacker.last_action = 2;
      }


      if (attacker.name === "Doudou" || attacker.name === "Diva" || attacker.name === "Cocobi") {
        attacker.spe += 0.20;
        if (!isPlayer && attacker.isDefending) {
          attacker.spe -= 0.20;
          attacker.isDefending = false;
        }
      } else {
        attacker.spe += 0.25;
        if (!isPlayer && attacker.isDefending) {
          attacker.spe -= 0.25
          attacker.isDefending = false;
        }
      }


      if (attacker.spe >= 1) {
        attacker.spe = 1;
      }


      let damage;


      if (attacker.immobilisation > 0) {
        damage = 0;
        specialLogMessage = `${defender.name} à immobilisé ${attacker.name} ! il ne peut donc pas attaquer.`;
        addCombatLog(specialLogMessage, logColor, isPlayer);
      } else if (defender.cape) {
        damage = 0;
        specialLogMessage = `${defender.name} à utilisé une cape de l'ombre, ${attacker.name} ne l'as donc pas atteint !`;
        addCombatLog(specialLogMessage, logColor, isPlayer);
      } else {

        // Calculer une défense aléatoire entre 85% et 115% de la défense originale de l'adversaire
        const defenseModifier = 0.9 + Math.random() * 0.2; // Entre 0.9 et 1.1
        const modifiedDefense = Math.round(defender.defense * defenseModifier);
        damage = Math.max(0, attacker.attaque - modifiedDefense);

        if (defender.defense_bouton === 1) {
          defender.defense_bouton = 0;
          damage = Math.round(attacker.attaque * 0.2); // Infliger 0 dégâts si la défense est activée
        }


        // Mettre à jour les PV du défenseur
        opponentCharacter.degats_subit = damage;
        let currentPV = defender.pv - damage;
        if (currentPV < 0) {
          currentPV = 0;
        }
        defender.pv = currentPV;

        if (isPlayerAttacking) {
          specialLogMessage = `Vous attaquez et infligez ${damage} points de dégâts à ${defender.name}.`;
          document.getElementById('opponent-pv').textContent = `PV: ${currentPV}`;
        } else {
          specialLogMessage = `${attacker.name} attaque et inflige ${damage} points de dégâts.`;
          document.getElementById('player-pv').textContent = `PV: ${currentPV}`;
        }
        addCombatLog(specialLogMessage, logColor, isPlayer);

        if (isPlayerAttacking) {
          playerCharacter.degats_partie += damage;
          if (playerCharacter.spe >= 0.1) {
            playerCharacter.degats_partie_base += damage;
          }
        }
      }

      // Vérifier si le défenseur est vaincu
      if (defender.pv === 0) {
        const userData = getUserData();
        let perteTrophees = 0;

        if (isPlayerAttacking) {
          userData.victoires += 1;
          userData.trophees += 10;
          userData.fin_trophee = 10;
          if (userData.parties_test < 5) {
            userData.trophees -= 10;
          }

        } else {

          userData.defaites += 1;
          if (userData.trophees < 150) {
            perteTrophees = 1
          } else if (userData.trophees <= 150) {
            perteTrophees = 3;
          } else if (userData.trophees <= 300) {
            perteTrophees = 5;
          } else if (userData.trophees <= 500) {
            perteTrophees = 8;
          } else if (userData.trophees <= 750) {
            perteTrophees = 10;
          } else {
            perteTrophees = 12;
          }

          if (userData.parties_test < 5) {
            perteTrophees = 0;
          }

          userData.trophees -= perteTrophees;
          if (userData.trophees < 0) {
            userData.trophees = 0;
          }
          saveUserData(userData);
        }

        let gain_XP = calculateXP(attacker, defender, isPlayerAttacking);
        let gain_argent = Math.round(gain_XP / 3);
        if (gain_XP < 20 && isPlayerAttacking) {
          gain_XP = 20;
        }
        if (userData.XP_jour >= 2500) {
          gain_XP = 0;
        }
        userData.XP_jour += gain_XP;

        saveUserData(userData);

        if (userData.Double_XP > 0) {
          gain_XP *= 2;
          userData.Double_XP -= 1;
        } else if (userData.Double_XP_acheté > 0) {
          userData.Double_XP_acheté -= 1;
          gain_XP *= 2;
        }
        if (userData.parties_test < 5) {
          gain_argent = 0;
          gain_XP = 0;
          userData.parties_test += 1;
          saveUserData(userData);
        }
        userData.pass_XP += gain_XP;
        saveUserData(userData);

        updateCharacterXP(userData, playerCharacter.name, gain_XP);
        userData.argent += gain_argent;

        if (isPlayerAttacking) {
          specialLogMessage = `${defender.name} a été vaincu !`;
          addCombatLog(specialLogMessage, logColor, "milieu");
          userData.gagnant = attacker.name;
          userData.fin_xp = gain_XP;
          userData.fin_argent = gain_argent;
          saveUserData(userData);
        } else {
          specialLogMessage = `${attacker.name} vous a vaincu !`;
          addCombatLog(specialLogMessage, logColor, "milieu");
          userData.gagnant = attacker.name;
          userData.fin_xp = gain_XP;
          userData.fin_argent = gain_argent;
          userData.fin_trophee = -perteTrophees;
          saveUserData(userData);
        }
        saveUserData(userData);

        document.getElementById('attack-button').disabled = true;
        document.getElementById('special-button').disabled = true;

        for (let week = 1; week <= 5; week++) {
          if (userData[`semaine${week}`]) {
            for (let quest = 1; quest <= 5; quest++) {
              const questKey = `Semaine${week}_${quest}`;
              const questCompletedKey = `${questKey}_completed`;
              const questTypeKey = `${questKey}_type`;
              const questCurrentKey = `${questKey}_current`;
              const questCharacter = `${questKey}_character`;

              if (!userData[questCompletedKey]) {
                switch (userData[questTypeKey]) {
                  case 'VCS':
                    if (isPlayerAttacking) {
                      userData[questCurrentKey] += 1;
                      saveUserData(userData);
                    }
                  case 'CC':
                    userData[questCurrentKey] += playerCharacter.capacite_partie;
                    saveUserData(userData);
                    break;
                  case 'VPCS':
                    if (isPlayerAttacking && playerCharacter.name === userData[questCharacter]) {
                      userData[questCurrentKey] += 1;
                      saveUserData(userData);
                    }
                    break;
                  case 'DSC':
                    userData[questCurrentKey] += playerCharacter.degats_partie;
                    saveUserData(userData);
                    break;
                  case 'O':
                    userData[questCurrentKey] += playerCharacter.objets_partie;
                    saveUserData(userData);
                    break;
                  case 'DC':
                    userData[questCurrentKey] += playerCharacter.defense_partie;
                    saveUserData(userData);
                    break;
                }
                saveUserData(userData);
              }
            }
          }
        }

        if (userData.quete1_type === "victoire_classique" && playerCharacter.name === userData.quete1_character && isPlayerAttacking) {
          userData.quete1_current += 1;
          saveUserData(userData);
        } else if (userData.quete1_type === "dommages_classique") {
          userData.quete1_current += playerCharacter.degats_partie;
          saveUserData(userData);
        } else if (userData.quete1_type === "objets_total") {
          userData.quete1_current += playerCharacter.objets_partie;
          saveUserData(userData);
        } else if (userData.quete1_type === "defense_classique") {
          userData.quete1_current += playerCharacter.defense_partie;
          saveUserData(userData);
        }

        if (userData.quete2_type === "victoire_classique" && playerCharacter.name === userData.quete2_character && isPlayerAttacking) {
          userData.quete2_current += 1;
          saveUserData(userData);
        } else if (userData.quete2_type === "dommages_classique") {
          userData.quete2_current += playerCharacter.degats_partie;
          saveUserData(userData);
        } else if (userData.quete2_type === "objets_total") {
          userData.quete2_current += playerCharacter.objets_partie;
          saveUserData(userData);
        } else if (userData.quete2_type === "defense_classique") {
          userData.quete2_current += playerCharacter.defense_partie;
          saveUserData(userData);
        }

        if (userData.quete3_type === "victoire_classique" && playerCharacter.name === userData.quete3_character && isPlayerAttacking) {
          userData.quete3_current += 1;
          saveUserData(userData);
        } else if (userData.quete3_type === "dommages_classique") {
          userData.quete3_current += playerCharacter.degats_partie;
          saveUserData(userData);
        } else if (userData.quete3_type === "objets_total") {
          userData.quete3_current += playerCharacter.objets_partie;
          saveUserData(userData);
        } else if (userData.quete3_type === "defense_classique") {
          userData.quete3_current += playerCharacter.defense_partie;
          saveUserData(userData);
        }

        updateCharacterXP(userData, playerCharacter.name, gain_XP);
        userData.argent += gain_argent;

        // Enregistrer le gagnant et les récompenses dans sessionStorage
        checkAndDisplayCharacterUnlock(userData);
        saveUserData(userData);
        setTimeout(() => {
          localStorage.removeItem("savepartie");
          sessionStorage.removeItem('playerCharacter');
          sessionStorage.removeItem('opponentCharacter');
          window.location.href = 'fin_partie.html';
        }, 2000);
      } else if (isPlayerAttacking) {
        // Tour de l'adversaire si le joueur attaque et n'a pas encore vaincu l'adversaire
        opponentTurn();
        updateSpecialBar(playerCharacter, 'player-special-bar');
        updateSpecialBar(opponentCharacter, 'opponent-special-bar');
        updateUI();
      }

      updateSpecialButton();
      scrollToBottom();
    }

    function calculateXP(attacker, defender, isPlayerAttacking) {
      let userData = getUserData();
      let niveau = Number(userData[attacker.name + "_Level"]) * 0.1;
      if (isPlayerAttacking) {
        let joueur_pv = attacker.pv;
        let joueur_pv_base = attacker.pv_max;
        return Math.round((2 * (joueur_pv / joueur_pv_base) * 100) * (1 / (1 + niveau)));
      } else if (userData.XP_jour >= 2500) {
        return 0;
      } else {
        return Math.round(20 - (2 * (niveau - 1)));
      }
    }

    function updateCharacterXP(userData, characterName, xp) {

      switch (characterName) {
        case "Willy":
          userData.Willy_XP += xp;
          break;
        case "Cocobi":
          userData.Cocobi_XP += xp;

          break;
        case "Oiseau":
          userData.Oiseau_XP += xp;

          break;
        case "Grours":
          userData.Grours_XP += xp;

          break;
        case "Baleine":
          userData.Baleine_XP += xp;

          break;
        case "Doudou":
          userData.Doudou_XP += xp;

          break;
        case "Coeur":
          userData.Coeur_XP += xp;

          break;
        case "Diva":
          userData.Diva_XP += xp;

          break;
        case "Poulpy":
          userData.Poulpy_XP += xp;

          break;
        case "Colorina":
          userData.Colorina_XP += xp;

          break;
          saveUserData(userData);
      }
    }

    function scrollToBottom() {
      const combatLog = document.getElementById('combat-log');
      combatLog.scrollTop = combatLog.scrollHeight;
    }
    // Fonction pour vérifier et afficher le déblocage d'un nouveau personnage
    function checkAndDisplayCharacterUnlock(userData) {
      // Définition des paliers de récompense avec des écarts de plus en plus grands
      const rewardPals = [
        {trophies: 10},
        {trophies: 20},
        {trophies: 30},
        {trophies: 40},
        {trophies: 60},
        {trophies: 80},
        {trophies: 100},
        {trophies: 120},
        {trophies: 150},
        {trophies: 180},
        {trophies: 220},
        {trophies: 260},
        {trophies: 300},
        {trophies: 350},
        {trophies: 400},
        {trophies: 460},
        {trophies: 520},
        {trophies: 580},
        {trophies: 650},
        {trophies: 720},
        {trophies: 800},
        {trophies: 880},
        {trophies: 970},
        {trophies: 1060},
        {trophies: 1150},
        {trophies: 1250},
        {trophies: 1350},
        {trophies: 1460},
        {trophies: 1570},
        {trophies: 1690}
      ];

      // Initialiser les paliers de récompense si non défini
      if (!userData.palier_recompense) {
        userData.palier_recompense = [];
      }

      let newPalsReached = 0;

      for (const reward of rewardPals) {
        if (userData.trophees >= reward.trophies) {
          if (!userData.palier_recompense.includes(reward.trophies)) {
            userData.palier_recompense.push(reward.trophies);
            userData.recompense += 1;
            newPalsReached++;
          }
        }
      }

      // Ajouter un personnage récompense tous les 8 nouveaux paliers atteints
      if (newPalsReached > 0 && (userData.palier_recompense.length % 10 === 0)) {
        userData.perso_recompense = (userData.perso_recompense || 0) + 1;
      }

      saveUserData(userData);
    }

    function sauvegarderPartie(playerCharacter, opponentCharacter) {
      const sauvegarde = {
        playerCharacter: {
          name: playerCharacter.name,
          pv: playerCharacter.pv,
          pv_max: playerCharacter.pv_max,
          attaque: playerCharacter.attaque,
          defense: playerCharacter.defense,
          spe: playerCharacter.spe,
          attaque_originale: playerCharacter.attaque_originale,
          defense_originale: playerCharacter.defense_originale,
          perte_att: playerCharacter.perte_att,
          Oiseaudefense: playerCharacter.Oiseaudefense,
          perte_defense_colorina: playerCharacter.perte_defense_colorina,
          amulette_soin: playerCharacter.amulette_soin,
          attaque_epee: playerCharacter.attaque_epee,
          attaque_elixir: playerCharacter.attaque_elixir,
          armure: playerCharacter.armure,
          degats_partie: playerCharacter.degats_partie,
          objets_partie: playerCharacter.objets_partie,
          capacite_partie: playerCharacter.capacite_partie,
          degats_partie_base: playerCharacter.degats_partie_base,
          objets_soin: playerCharacter.objets_soin,
          defense_bouton: playerCharacter.defense_bouton,
          defense_droit: playerCharacter.defense_droit,
          defense_solide: playerCharacter.defense_solide,
          defense_partie: playerCharacter.defense_partie,
          immobilisation: playerCharacter.immobilisation || 0,
          sboonie_attaque: playerCharacter.sboonie_attaque || 0,
          poulpy_att: playerCharacter.poulpy_att || 0,
          objets_utilise: playerCharacter.objets_utilise || 0,
          inventaire_objets: playerCharacter.inventaire_objets || false,
          amuletteUses: playerCharacter.amuletteUses || 0,
          armureUses: playerCharacter.armureUses || 0,
          tour: playerCharacter.tour || 1,
          cape: playerCharacter.cape || false,
          capeUses: playerCharacter.capeUses || 0,
          crystalUses: playerCharacter.crystalUses || 0,
          inconnu_super: playerCharacter.inconnu_super || 0,
          last_action: playerCharacter.last_action || 0,
          tourTT: playerCharacter.tourTT || 1,
        },
        opponentCharacter: {
          name: opponentCharacter.name,
          pv: opponentCharacter.pv,
          pv_max: opponentCharacter.pv_max,
          attaque: opponentCharacter.attaque,
          defense: opponentCharacter.defense,
          spe: opponentCharacter.spe,
          attaque_originale: opponentCharacter.attaque_originale,
          defense_originale: opponentCharacter.defense_originale,
          perte_att: opponentCharacter.perte_att || 0,
          Oiseaudefense: opponentCharacter.Oiseaudefense || 0,
          perte_defense_colorina: opponentCharacter.perte_defense_colorina || 0,
          pv_maximum: opponentCharacter.pv,
          immobilisation: opponentCharacter.immobilisation || 0,
          defense_bouton: opponentCharacter.defense_bouton || 0,
          defense_droit: opponentCharacter.defense_droit || 0,
          sboonie_attaque: opponentCharacter.sboonie_attaque || 0,
          poulpy_att: opponentCharacter.poulpy_att || 0,
          degats_subit: opponentCharacter.degats_subit || 0,
          inconnu_super: opponentCharacter.inconnu_super || 0,
          next_choice: opponentCharacter.next_choice || "0",
          isDefending: opponentCharacter.isDefending || false,
        }
      };

      localStorage.setItem("savepartie", JSON.stringify(sauvegarde));
    }

    userData.partie_commencee = true;
    saveUserData(userData);
  </script>
</body>

</html>