<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Combat</title>

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: url('background.jpg') no-repeat center center fixed;
      background-size: cover;
      color: #333;
      transition: background-color 0.3s, color 0.3s;
    }

    .top-bar {
      width: 100%;
      height: 100px;
      /* Hauteur de la barre */
      background-color: #d1d1d6;
      display: flex;
      align-items: center;
      /* Centrer verticalement */
      padding: 10px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      z-index: 1000;
      position: relative;
      /* Pour la superposition avec les éléments fixés */
    }

    .header-container {
      display: flex;
      justify-content: space-between;
      width: 100%;
      box-sizing: border-box;
    }

    .header-info {
      display: flex;
      flex-direction: column;
      margin: 0 10px;
    }

    .header-info h3 {
      margin: 0;
      padding: 0;
    }

    .header-info p {
      margin: 5px 0;
      padding: 0;
    }

    #player-money {
      display: none;
      /* Masquer l'affichage de l'argent */
    }

    .combat-container {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      /* Ajuster pour que le combat-log soit plus haut */
      align-items: center;
      padding: 20px;
      box-sizing: border-box;
      /* Inclure le padding dans la taille totale */
    }

    #combat-log {
      width: 100%;
      max-width: 600px;
      padding: 10px;
      background-color: #f0f0f0;
      border: 1px solid #ccc;
      height: 300px;
      overflow-y: scroll;
      margin-top: 0;
      /* Réduire ou supprimer la marge supérieure */
    }

    .combat-actions-wrapper {
      position: fixed;
      bottom: 50px;
      width: 100%;
      background-color: white;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1);
      padding: 10px;
    }

    .combat-actions {
      display: flex;
      justify-content: space-around;
    }

    .combat-actions button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      background-color: #ff4500;
      color: white;
      border-radius: 5px;
      transition: background-color 0.3s, transform 0.3s;
      touch-action: manipulation;
    }

    .combat-actions button:hover {
      background-color: #e03e00;
      transform: scale(1.05);
    }

    #item-selection {
      display: none;
      text-align: center;
      margin-top: 10px;
      padding: 10px;
      background: rgba(0, 0, 0, 0.8);
      /* Fond semi-transparent */
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
      /* Ombre portée */
    }

    #item-selection h3 {
      margin: 0;
      padding: 10px 0;
      color: #fff;
    }

    #item-selection button {
      display: block;
      width: 100%;
      max-width: 200px;
      padding: 15px;
      margin: 10px auto;
      font-size: 18px;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background-color: #4CAF50;
      /* Couleur de fond verte */
      color: white;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      /* Ombre portée */
      transition: background-color 0.3s, transform 0.3s;
    }

    #item-selection button:hover {
      background-color: #45a049;
      /* Couleur de fond au survol */
      transform: scale(1.05);
    }

    #item-selection button:active {
      background-color: #388e3c;
      /* Couleur de fond lors du clic */
      transform: scale(1.02);
    }

    /* Styles pour le thème sombre */
    .dark-theme {
      background-color: #000000;
      color: #e0e0e0;
    }

    .dark-theme .top-bar {
      background-color: #333333;
    }

    .dark-theme .combat-actions-wrapper {
      background-color: #222222;
    }

    .dark-theme .combat-actions button {
      background-color: #444444;
      color: #e0e0e0;
    }

    .dark-theme .combat-actions button:hover {
      background-color: #555555;
    }

    .dark-theme #combat-log {
      background-color: #333333;
      border: 1px solid #444444;
      color: #e0e0e0;
    }

    .dark-theme #item-selection {
      background-color: #333333;
      color: #e0e0e0;
      border: 1px solid #444444;
    }

    .dark-theme #item-selection button {
      background-color: #444444;
      color: #e0e0e0;
      border: 1px solid #555555;
    }

    .dark-theme #item-selection button:hover {
      background-color: #555555;
    }
  </style>
</head>

<body>
  <div class="top-bar">
    <div class="header-container">
      <div id="player-header" class="header-info">
        <h3 id="player-name"></h3>
        <p id="player-pv"></p>
        <!-- L'argent est masqué -->
        <!-- <p id="player-money"></p> -->
        <p id="player-attack"></p>
        <p id="player-defense"></p>
      </div>
      <div id="opponent-header" class="header-info">
        <h3 id="opponent-name"></h3>
        <p id="opponent-pv"></p>
        <p id="opponent-attack"></p>
        <p id="opponent-defense"></p>
      </div>
    </div>
  </div>

  <div class="combat-container">
    <div id="combat-log"></div>
  </div>

  <div class="combat-actions-wrapper">
    <div class="combat-actions">
      <button id="attack-button" onclick="attack()">Attaquer</button>
      <button id="special-button" onclick="useSpecial()">Capacité spéciale</button>
      <button id="items-button" onclick="showItemSelection()">Objets</button>
    </div>
    <div id="item-selection">
      <h3>Choisissez un objet à utiliser</h3>
      <!-- Les boutons d'objets seront ajoutés dynamiquement -->
      <button onclick="hideItemSelection()">Annuler</button>
    </div>
  </div>



  <script>
    function getUserData() {
      userData = JSON.parse(localStorage.getItem('userData'));
      if (userData.theme) {
        document.body.classList.add('dark-theme');
      }
      return userData;
    }
    getUserData()
    function saveUserData(userData) {
      localStorage.setItem('userData', JSON.stringify(userData));
    }
    // Récupérer les statistiques du personnage choisi depuis sessionStorage
    let playerCharacter = sessionStorage.getItem('playerCharacter');
    if (playerCharacter) {
      playerCharacter = JSON.parse(playerCharacter);

      // Ajouter les nouvelles variables et initialisations
      playerCharacter.perte_att = 0;
      playerCharacter.Oiseaudefense = 0;
      playerCharacter.perte_defense_colorina = 0;
      playerCharacter.pv_maximum = playerCharacter.pv;
      playerCharacter.amulette_soin = 0;



    } else {
      // Rediriger vers index.html si les statistiques du personnage ne sont pas trouvées
      window.location.href = 'index.html';
    }

    // Récupérer les statistiques de l'adversaire depuis sessionStorage
    let opponentCharacter = sessionStorage.getItem('opponentCharacter');
    if (opponentCharacter) {
      opponentCharacter = JSON.parse(opponentCharacter);

      opponentCharacter.perte_att = 0;
      opponentCharacter.Oiseaudefense = 0;
      opponentCharacter.perte_defense_colorina = 0;
      opponentCharacter.pv_maximum = opponentCharacter.pv;
    } else {
      // Rediriger vers index.html si les statistiques de l'adversaire ne sont pas trouvées
      window.location.href = 'index.html';
    }
    // Empêcher le retour en arrière vers la page précédente
    history.replaceState(null, null, window.location.href);

    // Initialiser spe (capacité spéciale)
    let spe = playerCharacter.spe;

    // Mettre à jour l'interface utilisateur avec les statistiques du joueur
    document.getElementById('player-name').textContent = `${playerCharacter.name}`;
    document.getElementById('player-pv').textContent = `PV: ${playerCharacter.pv}`;

    // Mettre à jour l'interface utilisateur avec les statistiques de l'adversaire
    document.getElementById('opponent-name').textContent = `${opponentCharacter.name}`;
    document.getElementById('opponent-pv').textContent = `PV: ${opponentCharacter.pv}`;

    // Récupérer la capacité spéciale du joueur depuis sessionStorage
    let specialAbility = spe;

    // Mettre à jour le bouton de capacité spéciale
    updateSpecialButton();

    function updateSpecialButton() {
      const specialButton = document.getElementById('special-button');

      if (specialAbility >= 1) {
        specialButton.style.backgroundColor = 'red';
        specialButton.textContent = 'Capacité spéciale';
      } else {
        specialButton.style.backgroundColor = 'blue';
        specialButton.textContent = `${specialAbility.toFixed(1)} / 1`;

      }
    }
    function adversairepasser_tour() {
      if (opponentCharacter.perte_att > 0) {
        opponentCharacter.perte_att -= 1;
      } else if (opponentCharacter.perte_att <= 0) {
        opponentCharacter.attaque = opponentCharacter.attaque_originale;
        console.log(`${opponentCharacter.name} a récupéré son attaque originale.`);
      }
      if (opponentCharacter.Oiseaudefense > 0) {
        opponentCharacter.Oiseaudefense -= 1;
      } else if (opponentCharacter.Oiseaudefense <= 0) {
        opponentCharacter.defense = opponentCharacter.defense - 20;
        console.log(`${opponentCharacter.name} a récupéré sa défense originale.`);
      }
      if (opponentCharacter.perte_defense_colorina > 0) {
        opponentCharacter.perte_defense_colorina -= 1;
      } else if (opponentCharacter.perte_defense_colorina <= 0) {
        opponentCharacter.defense = opponentCharacter.defense_originale;
        console.log(`${opponentCharacter.name} a récupéré sa défense originale.`);
      }
    }

    function joueurpasser_tour() {
      if (playerCharacter.perte_att > 0) {
        playerCharacter.perte_att -= 1;
      } else if (playerCharacter.perte_att <= 0) {
        playerCharacter.attaque = playerCharacter.attaque_originale;
        console.log(`${playerCharacter.name} a récupéré son attaque originale.`);
      }
      if (playerCharacter.Oiseaudefense > 0) {
        playerCharacter.Oiseaudefense -= 1;
      } else if (playerCharacter.Oiseaudefense <= 0) {
        playerCharacter.defense = playerCharacter.defense - 20;
        console.log(`${playerCharacter.name} a récupéré sa défense originale.`);
      }
      if (playerCharacter.perte_defense_colorina > 0) {
        playerCharacter.perte_defense_colorina -= 1;
      } else if (playerCharacter.perte_defense_colorina <= 0) {
        playerCharacter.defense = playerCharacter.defense_originale;
        console.log(`${playerCharacter.name} a récupéré sa défense originale.`);
      }
      if (playerCharacter.amulette_soin > 0) {
        playerCharacter.amulette_soin -= 1;
        playerCharacter.pv = Math.round(playerCharacter.pv + (playerCharacter.pv_maximum * 0.05));
      }
    }

    function showItemSelection() {
      const itemSelectionDiv = document.getElementById('item-selection');
      itemSelectionDiv.style.display = 'block';

      // Clear previous items
      itemSelectionDiv.innerHTML = '<h3>Choisissez un objet à utiliser</h3>';

      // Add buttons for each item in the inventory
      const userData = getUserData();
      if (userData.Potion_de_Santé_acheté > 0) {
        const potionButton = document.createElement('button');
        potionButton.textContent = 'Potion de Santé' + ` (${userData.Potion_de_Santé_acheté})`;
        potionButton.onclick = function () {useItem('Potion de Santé');};
        itemSelectionDiv.appendChild(potionButton);
      } if (userData.Amulette_de_Régénération_acheté > 0) {
        const AmuletteButton = document.createElement('button');
        AmuletteButton.textContent = 'Amulette de Régénération' + ` (${userData.Amulette_de_Régénération_acheté})`;
        AmuletteButton.onclick = function () {useItem('Amulette de Régénération');};
        itemSelectionDiv.appendChild(AmuletteButton);
      }
      // Add other items dynamically if needed
      // Example:
      // if (userData.Other_Item) {
      //   const otherItemButton = document.createElement('button');
      //   otherItemButton.textContent = 'Other Item';
      //   otherItemButton.onclick = function() { useItem('Other_Item'); };
      //   itemSelectionDiv.appendChild(otherItemButton);
      // }

      // Add an "Annuler" button at the end
      const cancelButton = document.createElement('button');
      cancelButton.textContent = 'Annuler';
      cancelButton.onclick = hideItemSelection;
      itemSelectionDiv.appendChild(cancelButton);
    }

    function hideItemSelection() {
      document.getElementById('item-selection').style.display = 'none';
    }
    function useItem(itemName) {
      switch (itemName) {
        case 'Potion de Santé':
          // Exemple : Régénérer des PV
          userData = getUserData();
          userData.Potion_de_Santé_acheté -= 1;
          const ajoutPV = Math.round(playerCharacter.pv * 0.15); // Montant de guérison (peut être ajusté)
          playerCharacter.pv += ajoutPV;
          saveUserData(userData);
          if (playerCharacter.pv > playerCharacter.pv_maximum) {
            playerCharacter.pv = playerCharacter.pv_maximum;
          }
          break;
        case 'Amulette de Régénération':
          userData = getUserData();
          userData.Amulette_de_Régénération_acheté -= 1;
          playerCharacter.amulette_soin += 3;
          saveUserData(userData);
          break;
        // Ajoutez d'autres cas pour d'autres objets
        default:
          console.log('Objet non reconnu');
      }

      // Mettre à jour l'interface utilisateur
      document.getElementById('player-pv').textContent = `PV: ${playerCharacter.pv}`;

      // Masquer la sélection des objets
      hideItemSelection();

      // Ajoute une entrée dans le journal de combat
      const combatLog = document.getElementById('combat-log');
      const itemLogEntry = document.createElement('p');
      itemLogEntry.textContent = `${itemName} utilisé !`;
      combatLog.appendChild(itemLogEntry);

      scrollToBottom(); // Assurez-vous que la vue défile vers le bas
    }

    function useSpecial() {
      if (specialAbility >= 1) {
        // Décrémente la quantité de la capacité spéciale utilisée
        playerCharacter.spe -= 1;
        specialAbility -= 1;

        // Affiche l'effet de la capacité spéciale du joueur
        let specialLogMessage = "";

        switch (playerCharacter.name) {
          case "Diva":
            opponentCharacter.attaque *= 0.80;
            specialLogMessage = `${playerCharacter.name} utilise sa capacité spéciale ! L'attaque de ${opponentCharacter.name} est réduite à ${opponentCharacter.attaque.toFixed(2)} pour les 3 prochains tours.`;
            opponentCharacter.perte_att += 3;
            break;
          case "Willy":
            playerCharacter.spe -= 0.25;
            specialAbility -= 0.25;
            const opponentDefenseModifiee = 0.85 + Math.random() * 0.3; // Entre 0.85 et 1.15
            const opponentDefensee = Math.round(opponentCharacter.defense * opponentDefenseModifiee);
            opponentCharacter.pv += opponentDefensee - playerCharacter.attaque;
            specialLogMessage = `${playerCharacter.name} utilise sa capacité spéciale ! Il effectue deux attaques !\n\n${playerCharacter.name} attaque ${opponentCharacter.name} et inflige ${playerCharacter.attaque - opponentDefensee} points de dégâts.`;
            attack(); // Deuxième attaque
            break;
          case "Baleine":
            if (playerCharacter.defense < 29) {
              specialLogMessage = "Baleine n'a plus assez de défense pour utiliser sa capacité spéciale, il va donc attaquer.";
              attack(); // Attaque normale
            } else {
              specialLogMessage = "Baleine utilise sa capacité spéciale ! Il perd 10 de défense et gagne 1000 PV !";
              playerCharacter.spe -= 0.25;
              specialAbility -= 0.25;
              playerCharacter.defense -= 10;
              playerCharacter.pv += 1000;
              attack(); // Attaque normale après la capacité spéciale
            }
            break;
          case "Doudou":
            let regeneratedAmount;
            if (playerCharacter.pv < (playerCharacter.pv_max / 2)) {
              regeneratedAmount = Math.ceil(playerCharacter.pv * 0.15);
              specialLogMessage = `${playerCharacter.name} régénère ${regeneratedAmount} PV (15%).`;
            } else {
              regeneratedAmount = Math.ceil(playerCharacter.pv * 0.05);
              specialLogMessage = `${playerCharacter.name} régénère ${regeneratedAmount} PV (5%).`;
            }
            playerCharacter.pv += regeneratedAmount;
            if (playerCharacter.pv > playerCharacter.pv_max) {
              playerCharacter.pv = playerCharacter.pv_max;
            }
            attack();
            break;
          case "Cocobi":
            // Calculer la réduction des PV de l'adversaire
            const reductionAmount = Math.ceil(opponentCharacter.pv_maximum * 0.08);
            opponentCharacter.pv -= reductionAmount;

            // Vérifier si les PV de l'adversaire ne sont pas inférieurs à zéro
            if (opponentCharacter.pv < 0) {
              opponentCharacter.pv = 0;
            }

            specialLogMessage = `${playerCharacter.name} utilise sa capacité spéciale ! ${opponentCharacter.name} perd ${reductionAmount} PV.`;
            break;
          case "Coeur":
            const specialDamage = Math.round(playerCharacter.attaque * 1.5);
            if (playerCharacter.pv > (playerCharacter.pv_max / 2)) {
              const absorbedHealth = Math.round(specialDamage * 0.1);
              opponentCharacter.pv -= specialDamage;
              playerCharacter.pv += absorbedHealth;
              specialLogMessage = `${playerCharacter.name} utilise sa capacité spéciale ! Il inflige ${specialDamage} points de dégâts et récupère ${absorbedHealth} PV.`;
            } else {
              const absorbedHealth = Math.round(specialDamage * 0.15);
              opponentCharacter.pv -= specialDamage;
              playerCharacter.pv += absorbedHealth;
              specialLogMessage = `${playerCharacter.name} utilise sa capacité spéciale ! Il inflige ${specialDamage} points de dégâts et récupère ${absorbedHealth} PV.`;
            }

            // Assurez-vous que les PV de l'adversaire et du joueur ne dépassent pas les limites
            if (opponentCharacter.pv < 0) opponentCharacter.pv = 0;
            if (playerCharacter.pv > playerCharacter.pv_max) playerCharacter.pv = playerCharacter.pv_max;
            break;
          case "Gros Nounours":
            const Damage = 500 + playerCharacter.attaque;
            const defense = Math.round(opponentCharacter.defense * 0.5);
            opponentCharacter.pv -= (Damage - defense);

            // Ignorer le bouclier de l'adversaire
            specialLogMessage = `${playerCharacter.name} utilise sa capacité spéciale ! Il inflige ${Damage - defense} points de dégâts à ${opponentCharacter.name}, ignorant le bouclier.`;
            break;
          case "Poulpy":
            // Infliger des dégâts à l'adversaire
            const poulpyDamage = Math.round(playerCharacter.attaque * 1.75);
            // Ignorer 50% de la défense de l'adversaire
            const effectiveDefense = Math.round(opponentCharacter.defense * 0.6);
            const netDamage = Math.max(0, poulpyDamage - effectiveDefense);
            opponentCharacter.pv -= netDamage;
            // Réduire la défense de l'adversaire pour les deux prochains tours
            opponentCharacter.defense *= 0.85;
            opponentCharacter.perte_att += 2;

            specialLogMessage = `${playerCharacter.name} utilise sa capacité spéciale ! Il inflige ${netDamage} points de dégâts à ${opponentCharacter.name}, ignore 50% de sa défense et réduit sa défense de 15% pour les 2 prochains tours.`;
            break;
          case "Oiseau":
            const DamageOiseau = playerCharacter.attaque * 2.5;
            playerCharacter.defense += 20; // Augmentation de la défense
            specialLogMessage = `${playerCharacter.name} utilise sa capacité spéciale ! Il inflige ${DamageOiseau} points de dégâts et gagne 20 de défense.`;
            opponentCharacter.pv -= DamageOiseau;
            playerCharacter.Oiseaudefense += 2; // Durée de l'effet de la capacité spéciale
            break;
          case "Colorina":
            // Infliger 85% de l'attaque en dégâts
            const colorinaDamage = Math.round(playerCharacter.attaque * 0.85);
            opponentCharacter.pv -= colorinaDamage;

            // Réduire la défense de l'adversaire de 10% pour les 3 prochains tours
            opponentCharacter.defense *= 0.85;
            opponentCharacter.perte_defense_colorina += 3;

            specialLogMessage = `${playerCharacter.name} utilise sa capacité spéciale ! Il inflige ${colorinaDamage} points de dégâts et réduit la défense de ${opponentCharacter.name} de 15% pour les 3 prochains tours.`;
            break;
          default:
            specialLogMessage = `${playerCharacter.name} utilise sa capacité spéciale ! Effet spécifique à définir.`;
          // Ajouter ici le traitement pour d'autres personnages si nécessaire
        }

        // Met à jour l'affichage des PV du joueur
        document.getElementById('player-pv').textContent = `PV: ${playerCharacter.pv}`;

        // Met à jour le bouton après l'utilisation
        updateSpecialButton();

        // Ajoute une entrée dans le journal de combat
        const combatLog = document.getElementById('combat-log');
        const specialLogEntry = document.createElement('p');
        specialLogEntry.textContent = specialLogMessage;
        combatLog.appendChild(specialLogEntry);

        scrollToBottom();
      }
    }

    function opponentTurn() {
      // Décider aléatoirement si l'adversaire attaque ou utilise sa capacité spéciale
      const useSpecialMove = Math.random() < 0.5 && opponentCharacter.spe >= 1;

      if (useSpecialMove) {
        // Utiliser la capacité spéciale de l'adversaire
        if (opponentCharacter.spe >= 1) {
          opponentUseSpecial();
        } else {
          opponentAttack()
        }

      } else {
        // Attaquer
        opponentAttack();
      }
    }

    function opponentUseSpecial() {
      opponentCharacter.spe -= 1;

      // Affiche l'effet de la capacité spéciale de l'adversaire
      let specialLogMessage = "";

      switch (opponentCharacter.name) {
        case "Diva":
          playerCharacter.attaque *= 0.80;
          specialLogMessage = `${opponentCharacter.name} utilise sa capacité spéciale ! L'attaque de ${playerCharacter.name} est réduite à ${playerCharacter.attaque.toFixed(2)} pour les 3 prochains tours.`;
          playerCharacter.perte_att += 3;
          break;
        case "Willy":
          opponentCharacter.spe -= 0.25;
          specialAbility -= 0.25;
          const playerDefenseModifiee = 0.85 + Math.random() * 0.3; // Entre 0.85 et 1.15
          const playerDefensee = Math.round(playerCharacter.defense * playerDefenseModifiee);
          playerCharacter.pv += playerDefensee - opponentCharacter.attaque;
          specialLogMessage = `${opponentCharacter.name} utilise sa capacité spéciale ! Il effectue deux attaques !\n\n${opponentCharacter.name} attaque ${playerCharacter.name} et inflige ${opponentCharacter.attaque - playerDefensee} points de dégâts.`;
          attack(); // Deuxième attaque
          break;
        case "Baleine":
          if (opponentCharacter.defense < 29) {
            specialLogMessage = "Baleine n'a plus assez de défense pour utiliser sa capacité spéciale, il va donc attaquer.";
            attack(); // Attaque normale
          } else {
            specialLogMessage = "Baleine utilise sa capacité spéciale ! Il perd 10 de défense et gagne 1000 PV !";
            opponentCharacter.spe -= 0.25;
            specialAbility -= 0.25;
            opponentCharacter.defense -= 10;
            opponentCharacter.pv += 1000;
            attack(); // Attaque normale après la capacité spéciale
          }
          break;
        case "Doudou":
          let regeneratedAmount;
          if (opponentCharacter.pv < (opponentCharacter.pv_max / 2)) {
            regeneratedAmount = Math.ceil(opponentCharacter.pv * 0.15);
            specialLogMessage = `${opponentCharacter.name} régénère ${regeneratedAmount} PV (15%).`;
          } else {
            regeneratedAmount = Math.ceil(opponentCharacter.pv * 0.05);
            specialLogMessage = `${opponentCharacter.name} régénère ${regeneratedAmount} PV (5%).`;
          }
          opponentCharacter.pv += regeneratedAmount;
          if (opponentCharacter.pv > opponentCharacter.pv_max) {
            opponentCharacter.pv = opponentCharacter.pv_max;
          }
          attack();
          break;
        case "Cocobi":
          // Calculer la réduction des PV de l'adversaire
          const reductionAmount = Math.ceil(playerCharacter.pv_maximum * 0.08);
          playerCharacter.pv -= reductionAmount;

          // Vérifier si les PV de l'adversaire ne sont pas inférieurs à zéro
          if (playerCharacter.pv < 0) {
            playerCharacter.pv = 0;
          }

          specialLogMessage = `${opponentCharacter.name} utilise sa capacité spéciale ! ${playerCharacter.name} perd ${reductionAmount} PV.`;
          break;
        case "Coeur":
          const specialDamage = Math.round(opponentCharacter.attaque * 1.5);
          if (opponentCharacter.pv > (opponentCharacter.pv_max / 2)) {
            const absorbedHealth = Math.round(specialDamage * 0.1);
            playerCharacter.pv -= specialDamage;
            opponentCharacter.pv += absorbedHealth;
            specialLogMessage = `${opponentCharacter.name} utilise sa capacité spéciale ! Il inflige ${specialDamage} points de dégâts et récupère ${absorbedHealth} PV.`;
          } else {
            const absorbedHealth = Math.round(specialDamage * 0.15);
            playerCharacter.pv -= specialDamage;
            opponentCharacter.pv += absorbedHealth;
            specialLogMessage = `${opponentCharacter.name} utilise sa capacité spéciale ! Il inflige ${specialDamage} points de dégâts et récupère ${absorbedHealth} PV.`;
          }

          // Assurez-vous que les PV de l'adversaire et du joueur ne dépassent pas les limites
          if (playerCharacter.pv < 0) playerCharacter.pv = 0;
          if (opponentCharacter.pv > opponentCharacter.pv_max) opponentCharacter.pv = opponentCharacter.pv_max;
          break;
        case "Gros Nounours":
          const Damage = 500 + opponentCharacter.attaque;
          const defense = Math.round(playerCharacter.defense * 0.5);
          playerCharacter.pv -= (Damage - defense);

          // Ignorer le bouclier de l'adversaire
          specialLogMessage = `${opponentCharacter.name} utilise sa capacité spéciale ! Il inflige ${Damage - defense} points de dégâts à ${playerCharacter.name}, ignorant le bouclier.`;
          break;
        case "Poulpy":
          // Infliger des dégâts à l'adversaire
          const poulpyDamage = Math.round(opponentCharacter.attaque * 1.75);
          // Ignorer 50% de la défense de l'adversaire
          const effectiveDefense = Math.round(playerCharacter.defense * 0.6);
          const netDamage = Math.max(0, poulpyDamage - effectiveDefense);
          playerCharacter.pv -= netDamage;
          // Réduire la défense de l'adversaire pour les deux prochains tours
          playerCharacter.defense *= 0.85;
          playerCharacter.perte_att += 2;

          specialLogMessage = `${opponentCharacter.name} utilise sa capacité spéciale ! Il inflige ${netDamage} points de dégâts à ${playerCharacter.name}, ignore 50% de sa défense et réduit sa défense de 15% pour les 2 prochains tours.`;
          break;
        case "Oiseau":
          const DamageOiseau = opponentCharacter.attaque * 2.5;
          opponentCharacter.defense += 20; // Augmentation de la défense
          specialLogMessage = `${opponentCharacter.name} utilise sa capacité spéciale ! Il inflige ${DamageOiseau} points de dégâts et gagne 20 de défense.`;
          playerCharacter.pv -= DamageOiseau;
          opponentCharacter.Oiseaudefense += 2; // Durée de l'effet de la capacité spéciale
          break;
        case "Colorina":
          // Infliger 85% de l'attaque en dégâts
          const colorinaDamage = Math.round(opponentCharacter.attaque * 0.85);
          playerCharacter.pv -= colorinaDamage;

          // Réduire la défense de l'adversaire de 10% pour les 3 prochains tours
          playerCharacter.defense *= 0.85;
          playerCharacter.perte_defense_colorina += 3;

          specialLogMessage = `${opponentCharacter.name} utilise sa capacité spéciale ! Il inflige ${colorinaDamage} points de dégâts et réduit la défense de ${playerCharacter.name} de 15% pour les 3 prochains tours.`;
          break;
        default:
          specialLogMessage = `${opponentCharacter.name} utilise sa capacité spéciale ! Effet spécifique à définir.`;
        // Ajouter ici le traitement pour d'autres personnages si nécessaire
      }


      // Met à jour l'affichage des PV du joueur
      document.getElementById('opponent-pv').textContent = `PV: ${opponentCharacter.pv}`;

      // Ajoute une entrée dans le journal de combat
      const combatLog = document.getElementById('combat-log');
      const specialLogEntry = document.createElement('p');
      specialLogEntry.textContent = specialLogMessage;
      combatLog.appendChild(specialLogEntry);

      scrollToBottom();
      adversairepasser_tour();
      joueurpasser_tour();
    }

    function opponentAttack() {
      // Augmenter spe de 0.25 à chaque attaque
      if (opponentCharacter.name === "Doudou" || opponentCharacter.name === "Diva" || opponentCharacter.name === "Cocobi") {
        opponentCharacter.spe += 0.20;
      } else {
        opponentCharacter.spe += 0.25;
      }
      // Calculer une défense aléatoire entre 85% et 115% de la défense originale du joueur
      const playerDefenseModifier = 0.85 + Math.random() * 0.3; // Entre 0.85 et 1.15
      const opponentDefenseModifier = 0.85 + Math.random() * 0.3; // Entre 0.85 et 1.15

      const playerDefense = Math.round(playerCharacter.defense * playerDefenseModifier);
      const opponentDefense = Math.round(opponentCharacter.defense * opponentDefenseModifier);

      const playerDamage = Math.max(0, playerCharacter.attaque - opponentDefense);
      const opponentDamage = Math.max(0, opponentCharacter.attaque - playerDefense);

      const combatLog = document.getElementById('combat-log');

      // Simulation de l'attaque de l'adversaire
      const opponentLogEntry = document.createElement('p');
      opponentLogEntry.textContent = `${opponentCharacter.name} attaque et inflige ${opponentDamage} points de dégâts.`;
      combatLog.appendChild(opponentLogEntry);

      // Mettre à jour les PV du joueur
      let currentPlayerPV = playerCharacter.pv - opponentDamage;
      if (currentPlayerPV < 0) {
        currentPlayerPV = 0;
      }
      document.getElementById('player-pv').textContent = `PV: ${currentPlayerPV}`;
      playerCharacter.pv = currentPlayerPV;

      // Vérifier si le joueur est vaincu
      if (currentPlayerPV === 0) {
        let userData = getUserData();
        userData.defaites += 1;
        let perteTrophees = Math.min(20, Math.floor(userData.trophees / 2));
        userData.trophees = Math.max(0, userData.trophees - perteTrophees);
        let character = playerCharacter.name;
        let niveau = Number(userData[character + "_Level"]) * 0.1;
        let gain_XP = 10 * (1 / (1 + niveau));
        gain_XP = Math.round(gain_XP); // Arrondir au nombre entier le plus proche
        let gain_argent = Math.round(gain_XP / 4);
        if (userData.Double_XP > 0) {
          gain_XP *= 2;
          userData.Double_XP -= 1;
        } else if (userData.Double_XP_acheté > 0) {
          userData.Double_XP_acheté -= 1;
          gain_XP *= 2;
        }

        if (playerCharacter.name === "Willy") {
          userData.Willy_XP += gain_XP;
        } else if (playerCharacter.name === "Cocobi") {
          userData.Cocobi_XP += gain_XP;
        } else if (playerCharacter.name === "Oiseau") {
          userData.Diva_XP += gain_XP;
        } else if (playerCharacter.name === "Gros_Nounours") {
          userData.Gros_Nounours_XP += gain_XP;
        } else if (playerCharacter.name === "Baleine") {
          userData.Baleine_XP += gain_XP;
        } else if (playerCharacter.name === "Doudou") {
          userData.Doudou_XP += gain_XP;
        } else if (playerCharacter.name === "Coeur") {
          userData.Coeur_XP += gain_XP;
        } else if (playerCharacter.name === "Diva") {
          userData.Diva_XP += gain_XP;
        } else if (playerCharacter.name === "Poulpy") {
          userData.Poulpy_XP += gain_XP;
        } else if (playerCharacter.name === "Colorina") {
          userData.Colorina_XP += gain_XP;
        }
        userData.argent += gain_argent;


        combatLog.innerHTML += `<p>${opponentCharacter.name} vous à vaincu ! Vous perdez ${perteTrophees} trophées</p>`;
        combatLog.innerHTML +=
          `<p>Vous avez gagné ${gain_XP} XP et vous avez reçu ${gain_argent} points</p>`;
        document.getElementById('attack-button').disabled = true;


        // Rediriger vers index.html après la fin du combat
        setTimeout(() => {
          sessionStorage.removeItem('playerCharacter');
          sessionStorage.removeItem('opponentCharacter');
          window.location.href = 'menu_principal.html';
        }, 2000); // 2 secondes de délai avant redirection
        saveUserData(userData);
      }

      scrollToBottom();
    }

    function attack() {
      // Augmenter spe de 0.25 à chaque attaque
      if (playerCharacter.name === "Doudou" || playerCharacter.name === "Diva" || playerCharacter.name === "Cocobi" ) {
        specialAbility = Math.min(1, specialAbility + 0.20);
      } else {
        specialAbility = Math.min(1, specialAbility + 0.25);
      }
      updateSpecialButton();

      // Mettre à jour specialAbility (pour le bouton de capacité spéciale)
      spe = specialAbility;
      specialAbility = spe;

      // Calculer une défense aléatoire entre 85% et 115% de la défense originale de l'adversaire
      const playerDefenseModifier = 0.85 + Math.random() * 0.3; // Entre 0.85 et 1.15
      const opponentDefenseModifier = 0.85 + Math.random() * 0.3; // Entre 0.85 et 1.15

      const playerDefense = Math.round(playerCharacter.defense * playerDefenseModifier);
      const opponentDefense = Math.round(opponentCharacter.defense * opponentDefenseModifier);

      const playerDamage = Math.max(0, playerCharacter.attaque - opponentDefense);
      const opponentDamage = Math.max(0, opponentCharacter.attaque - playerDefense);

      const combatLog = document.getElementById('combat-log');

      // Simulation de l'attaque du joueur
      const playerLogEntry = document.createElement('p');
      playerLogEntry.textContent = `Vous attaquez et infligez ${playerDamage} points de dégâts à ${opponentCharacter.name}.`;
      combatLog.appendChild(playerLogEntry);

      // Mettre à jour les PV de l'adversaire
      let currentOpponentPV = opponentCharacter.pv - playerDamage;
      if (currentOpponentPV < 0) {
        currentOpponentPV = 0;
      }
      document.getElementById('opponent-pv').textContent = `PV: ${currentOpponentPV}`;
      opponentCharacter.pv = currentOpponentPV;

      // Vérifier si l'adversaire est vaincu
      if (currentOpponentPV === 0) {
        let userData = getUserData();
        userData.victoires += 1;
        userData.trophees += 10;

        let character = playerCharacter.name;
        let niveau = Number(userData[character + "_Level"]) * 0.1;
        let joueur_pv = playerCharacter.pv;
        let joueur_pv_base = playerCharacter.pv_max;

        let gain_XP = (2 * (joueur_pv / joueur_pv_base) * 100) * (1 / (1 + niveau));
        gain_XP = Math.round(gain_XP); // Arrondir au nombre entier le plus proche
        let gain_argent = Math.round(gain_XP / 4);
        if (userData.Double_XP > 0) {
          gain_XP *= 2;
          userData.Double_XP -= 1;
        } else if (userData.Double_XP_acheté > 0) {
          userData.Double_XP_acheté -= 1;
          gain_XP *= 2;
        }

        if (playerCharacter.name === "Willy") {
          userData.Willy_XP += gain_XP;
        } else if (playerCharacter.name === "Cocobi") {
          userData.Cocobi_XP += gain_XP;
        } else if (playerCharacter.name === "Oiseau") {
          userData.Oiseau_XP += gain_XP;
        } else if (playerCharacter.name === "Gros_Nounours") {
          userData.Gros_Nounours_XP += gain_XP;
        } else if (playerCharacter.name === "Baleine") {
          userData.Baleine_XP += gain_XP;
        } else if (playerCharacter.name === "Doudou") {
          userData.Doudou_XP += gain_XP;
        } else if (playerCharacter.name === "Coeur") {
          userData.Coeur_XP += gain_XP;
        } else if (playerCharacter.name === "Diva") {
          userData.Diva_XP += gain_XP;
        } else if (playerCharacter.name === "Poulpy") {
          userData.Poulpy_XP += gain_XP;
        } else if (playerCharacter.name === "Colorina") {
          userData.Colorina_XP += (gain_XP);
        }
        userData.argent += gain_argent;

        combatLog.innerHTML += `<p>${opponentCharacter.name} a été vaincu ! Vous gagnez 10 trophées.</p>`;
        combatLog.innerHTML += `<p>Vous avez gagné ${gain_XP} XP et vous avez reçu ${gain_argent} points</p>`;

        document.getElementById('attack-button').disabled = true;

        // Vérifier le déblocage des personnages
        checkAndDisplayCharacterUnlock(userData);


        // Rediriger vers index.html après la fin du combat
        setTimeout(() => {
          sessionStorage.removeItem('playerCharacter');
          sessionStorage.removeItem('opponentCharacter');
          window.location.href = 'menu_principal.html';
        }, 2000); // 2 secondes de délai avant redirection
        saveUserData(userData);
      } else {
        // Tour de l'adversaire
        opponentTurn();
      }

      // Mettre à jour le bouton de capacité spéciale après chaque attaque
      adversairepasser_tour();
      joueurpasser_tour();
      updateSpecialButton();

      scrollToBottom();
    }

    function scrollToBottom() {
      const combatLog = document.getElementById('combat-log');
      combatLog.scrollTop = combatLog.scrollHeight;
    }
    // Fonction pour vérifier et afficher le déblocage d'un nouveau personnage
    function checkAndDisplayCharacterUnlock(userData) {
      // Définition des paliers de récompense avec des écarts de plus en plus grands
      const rewardPals = [
        {trophies: 10},
        {trophies: 20},
        {trophies: 30},
        {trophies: 40},
        {trophies: 60},
        {trophies: 80},
        {trophies: 100},
        {trophies: 120},
        {trophies: 150},
        {trophies: 180},
        {trophies: 220},
        {trophies: 260},
        {trophies: 300},
        {trophies: 350},
        {trophies: 400},
        {trophies: 460},
        {trophies: 520},
        {trophies: 580},
        {trophies: 650},
        {trophies: 720},
        {trophies: 800},
        {trophies: 880},
        {trophies: 970},
        {trophies: 1060},
        {trophies: 1150},
        {trophies: 1250},
        {trophies: 1350},
        {trophies: 1460},
        {trophies: 1570},
        {trophies: 1690}
      ];

      // Initialiser les paliers de récompense si non défini
      if (!userData.palier_recompense) {
        userData.palier_recompense = [];
      }

      let newPalsReached = 0;

      for (const reward of rewardPals) {
        if (userData.trophees >= reward.trophies) {
          if (!userData.palier_recompense.includes(reward.trophies)) {
            userData.palier_recompense.push(reward.trophies);
            userData.recompense += 1;
            newPalsReached++;
          }
        }
      }

      // Ajouter un personnage récompense tous les 8 nouveaux paliers atteints
      if (newPalsReached > 0 && (userData.palier_recompense.length % 10 === 0)) {
        userData.perso_recompense = (userData.perso_recompense || 0) + 1;
      }

      saveUserData(userData);
    }
  </script>
</body>

</html>